
> music-practice-app@0.0.0 test
> vitest


[1m[46m RUN [49m[22m [36mv4.0.9 [39m[90mC:/Users/gavin/repos/meta[39m

 [32mâœ“[39m src/utils/chordEngine.test.ts [2m([22m[2m81 tests[22m[2m)[22m[32m 34[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould start timer countdown when round begins
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould initialize session timer to configured duration
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mInitialization[2m > [22m[2mshould start in IDLE state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mInitialization[2m > [22m[2mshould initialize with empty context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould initialize session timer to configured duration
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.938Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould start timer countdown when round begins
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.937Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from IDLE to PLAYING on START_GAME
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mstarts with full health
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from IDLE to PLAYING on START_GAME
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.934Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to PAUSED on PAUSE
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Notes Tracking[2m > [22m[2mtracks progress toward targetNotes but does not complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to PAUSED on PAUSE
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PAUSED to PLAYING on RESUME
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mrecovers health on correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PAUSED to PLAYING on RESUME
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mBasic Rush Flow[2m > [22m[2mcompletes when target notes reached
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713904934-0.01753663675156547'[39m,
  timestamp: [35m2025-12-26T01:51:44.934Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mcaps health at maxHealth
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to COMPLETED on COMPLETE
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mloses health on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to COMPLETED on COMPLETE
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to IDLE on RESET
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mBasic Rush Flow[2m > [22m[2mhandles mixed correct/incorrect guesses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to IDLE on RESET
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Notes Tracking[2m > [22m[2mcontinues beyond target with mixed correct/incorrect
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mGame Over Conditions[2m > [22m[2mcompletes when health reaches zero
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mbuilds and maintains streak
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2memits stateChange event when transitioning from idle to playing
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mGame Over Conditions[2m > [22m[2mallows multiple incorrect guesses before death
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Accuracy Tracking[2m > [22m[2mtracks accuracy toward target but does not complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mIDLE â†’ PLAYING: startGame()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.962Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Accuracy Tracking[2m > [22m[2mcontinues even with 100% accuracy on first guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mGame Over Conditions[2m > [22m[2mcontinues game with correct guesses maintaining health
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713904962-0.7576506787555604'[39m,
  timestamp: [35m2025-12-26T01:51:44.962Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2memits stateChange event when transitioning from idle to playing
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstderr[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.test.ts:14:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.967Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Streak Tracking[2m > [22m[2mtracks streak toward target but does not complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2memits roundStart with generated note and feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mtransitions to playing.waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.968Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes NOT emit any orchestrator events
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould start in WAITING_INPUT round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2memits roundStart with generated note and feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.968Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mIDLE â†’ PLAYING: startGame()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mbuilds streak with correct guesses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.967Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould start in WAITING_INPUT round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes NOT emit any orchestrator events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.969Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mtransitions to playing.waiting_input state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to PROCESSING_GUESS after MAKE_GUESS
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to PROCESSING_GUESS after MAKE_GUESS
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to PROCESSING_GUESS after MAKE_GUESS
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to TIMEOUT_INTERMISSION after CORRECT_GUESS
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to TIMEOUT_INTERMISSION after CORRECT_GUESS
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901968-0.12139329170529467'[39m,
  timestamp: [35m2025-12-26T01:51:41.968Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to TIMEOUT_INTERMISSION after CORRECT_GUESS
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition back to WAITING_INPUT after ADVANCE_ROUND
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition back to WAITING_INPUT after ADVANCE_ROUND
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.973Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901969-0.28276223905935516'[39m,
  timestamp: [35m2025-12-26T01:51:41.969Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901971-0.3361979973952498'[39m,
  timestamp: [35m2025-12-26T01:51:41.971Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901972-0.7299830487794248'[39m,
  timestamp: [35m2025-12-26T01:51:41.972Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 3'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition back to WAITING_INPUT after ADVANCE_ROUND
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mclears all active timers before starting
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Streak Tracking[2m > [22m[2mrequires consecutive correct guesses for streak
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mmaintains current state after replay
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get current note from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mmaintains current state after replay
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.974Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get user guess from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get stats from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get feedback message from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mclears all active timers before starting
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713904967-0.8923521542639803'[39m,
  timestamp: [35m2025-12-26T01:51:44.967Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mMultiple Targets[2m > [22m[2mcontinues when one target is met but not others
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mgenerates note using configured note filter
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not change current note
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStats Tracking[2m > [22m[2mtracks correct and incorrect attempts
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould update stats after correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.976Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mcan be called from idle state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mMultiple Targets[2m > [22m[2mallows practice when no targets set
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mgenerates note using configured note filter
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.980Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not change current note
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.980Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould update stats after correct guess
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mcan be called from idle state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mdoes not complete when targets are met (only timer expiration completes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not affect stats
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves stats across multiple pauses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould notify subscribers on state changes
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ COMPLETED: complete()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2memits stateChange to paused when pause() called
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mtimer configuration is passed correctly for countdown mode
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.985Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not affect stats
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.983Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mprevents health from going negative
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.988Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould notify subscribers on state changes
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ COMPLETED: complete()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:41.981Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2memits stateChange to paused when pause() called
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.980Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcalls game mode onStartNewRound callback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called multiple times
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2msurvives with 1 HP remaining
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901989-0.3946538163424895'[39m,
  timestamp: [35m2025-12-26T01:51:41.989Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould unsubscribe correctly
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ IDLE: reset()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2memits stateChange to paused when pause() called
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713904980-0.19273341671712574'[39m,
  timestamp: [35m2025-12-26T01:51:44.980Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcalls game mode onStartNewRound callback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.990Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called multiple times
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.986Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.990Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould unsubscribe correctly
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ IDLE: reset()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:41.984Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: idle
[Orchestrator] Emitting event: stateChange { sessionState: [32m'idle'[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mhandles rapid health fluctuations
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from idle state (first round)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called from waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901991-0.14161398791932855'[39m,
  timestamp: [35m2025-12-26T01:51:41.991Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901992-0.9423834610550641'[39m,
  timestamp: [35m2025-12-26T01:51:41.992Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mCleanup[2m > [22m[2mshould clean up all subscriptions on stop
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from idle state (first round)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called from waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.991Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mCleanup[2m > [22m[2mshould clean up all subscriptions on stop
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:41.993Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.982Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from idle state (first round)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.997Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mlogs warning if no current note exists
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

 [32mâœ“[39m src/components/PianoKeyboard.test.tsx [2m([22m[2m4 tests[22m[2m)[22m[32m 169[2mms[22m[39m
[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.994Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [32mâœ“[39m src/game/SurvivalMode.test.ts [2m([22m[2m16 tests[22m[2m)[22m[32m 62[2mms[22m[39m
[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:134:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mlogs warning if no current note exists
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.993Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/GameOrchestrator.timeout.test.ts [2m([22m[2m7 tests[22m[2m | [22m[33m3 skipped[39m[2m)[22m[32m 58[2mms[22m[39m
[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901995-0.748499770736113'[39m,
  timestamp: [35m2025-12-26T01:51:41.995Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901983-0.5147225033955172'[39m,
  timestamp: [35m2025-12-26T01:51:41.983Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901983-0.540967467449613'[39m,
  timestamp: [35m2025-12-26T01:51:41.983Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.000Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mlogs warning if no current note exists
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.995Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [32mâœ“[39m src/game/GameOrchestrator.test.ts [2m([22m[2m20 tests[22m[2m)[22m[32m 52[2mms[22m[39m
[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902000-0.4821201955300456'[39m,
  timestamp: [35m2025-12-26T01:51:42.000Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902001-0.008322826504017389'[39m,
  timestamp: [35m2025-12-26T01:51:42.001Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart event with note
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901995-0.23884792977549973'[39m,
  timestamp: [35m2025-12-26T01:51:41.995Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901996-0.8113018989027296'[39m,
  timestamp: [35m2025-12-26T01:51:41.996Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901996-0.7279982905788072'[39m,
  timestamp: [35m2025-12-26T01:51:41.996Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 3'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.004Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart event with note
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.996Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.990Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.001Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mplays audio for the generated note
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.998Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902002-0.8340061878057221'[39m,
  timestamp: [35m2025-12-26T01:51:42.002Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mplays audio for the generated note
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.999Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713901999-0.6820101596101249'[39m,
  timestamp: [35m2025-12-26T01:51:41.999Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mfeedback message is mode-specific
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:41.999Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mfeedback message is mode-specific
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.012Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.001Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.002Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mroundStart includes context with note for ear training
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.001Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2memits stateChange for each pause/resume
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:159:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mroundStart includes context with note for ear training
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.016Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.001Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2memits stateChange for each pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.007Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.003Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902002-0.9842138304926651'[39m,
  timestamp: [35m2025-12-26T01:51:42.002Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902002-0.8995585060495279'[39m,
  timestamp: [35m2025-12-26T01:51:42.002Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.005Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart with mode-specific feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2memits stateChange for each pause/resume
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902004-0.6277326802838148'[39m,
  timestamp: [35m2025-12-26T01:51:42.004Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902005-0.6805592416587436'[39m,
  timestamp: [35m2025-12-26T01:51:42.005Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.019Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart with mode-specific feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.003Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mpreserves state through rapid cycles
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.006Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902020-0.5971521034901688'[39m,
  timestamp: [35m2025-12-26T01:51:42.020Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mpreserves state through rapid cycles
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.011Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902006-0.9349780604652296'[39m,
  timestamp: [35m2025-12-26T01:51:42.006Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.005Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.004Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mpreserves state through rapid cycles
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:147:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mdoes NOT emit any events when note duration changed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mpreserves state through rapid cycles
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902011-0.9150345605786279'[39m,
  timestamp: [35m2025-12-26T01:51:42.011Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mdoes NOT change state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessAttempt event with isCorrect: false
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.012Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.024Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mstores duration for next playback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.027Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessAttempt event with isCorrect: false
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.010Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902012-0.3062207867964961'[39m,
  timestamp: [35m2025-12-26T01:51:42.012Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902013-0.3761337893695893'[39m,
  timestamp: [35m2025-12-26T01:51:42.013Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902024-0.2568318698946779'[39m,
  timestamp: [35m2025-12-26T01:51:42.024Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mcan be changed multiple times
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:167:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessAttempt event with isCorrect: false
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'A'[39m, isCorrect: [33mfalse[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902011-0.1321464113054749'[39m,
  timestamp: [35m2025-12-26T01:51:42.011Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending incorrect_guess to state machine
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m'Incorrect. Accuracy: 0.0% | Streak reset'[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.009Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902027-0.40771260997371606'[39m,
  timestamp: [35m2025-12-26T01:51:42.027Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902028-0.04729302466887764'[39m,
  timestamp: [35m2025-12-26T01:51:42.028Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessResult event with incorrect feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.011Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessResult event with incorrect feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.015Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902010-0.46604757827439736'[39m,
  timestamp: [35m2025-12-26T01:51:42.010Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902011-0.6713142400464136'[39m,
  timestamp: [35m2025-12-26T01:51:42.011Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Notes: 1/10 | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.032Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessResult event with incorrect feedback
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'G'[39m, isCorrect: [33mfalse[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902015-0.7043467820777953'[39m,
  timestamp: [35m2025-12-26T01:51:42.015Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending incorrect_guess to state machine
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m'Incorrect. Accuracy: 0.0% | Streak reset'[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.011Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.027Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.012Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:186:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:201:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.016Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902028-0.7387597385986981'[39m,
  timestamp: [35m2025-12-26T01:51:42.028Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/AudioActions.test.ts:33:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902032-0.23143461549600097'[39m,
  timestamp: [35m2025-12-26T01:51:42.032Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902032-0.06104579934628873'[39m,
  timestamp: [35m2025-12-26T01:51:42.032Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.026Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902016-0.775126128725877'[39m,
  timestamp: [35m2025-12-26T01:51:42.016Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902016-0.7745424027416126'[39m,
  timestamp: [35m2025-12-26T01:51:42.016Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.029Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902026-0.6815083127114259'[39m,
  timestamp: [35m2025-12-26T01:51:42.026Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902029-0.022071025437015335'[39m,
  timestamp: [35m2025-12-26T01:51:42.029Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.035Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.027Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.023Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:207:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902029-0.413928516417045'[39m,
  timestamp: [35m2025-12-26T01:51:42.029Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.015Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39m[Orchestrator] submitGuess called: F
[Orchestrator] User submitted guess: F
[Orchestrator] Guess validation: { guessed: [32m'F'[39m, actual: [32m'F'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902023-0.09316988103196988'[39m,
  timestamp: [35m2025-12-26T01:51:42.023Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'F'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Notes: 1/10 | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902035-0.1827303579780748'[39m,
  timestamp: [35m2025-12-26T01:51:42.035Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902036-0.525665506231076'[39m,
  timestamp: [35m2025-12-26T01:51:42.036Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.030Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mauto-advance can be cancelled by pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/AudioActions.test.ts:33:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'F'[39m, isCorrect: [33mfalse[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902030-0.9247560455192243'[39m,
  timestamp: [35m2025-12-26T01:51:42.030Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending incorrect_guess to state machine
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m'Incorrect. Accuracy: 66.7% | Streak reset'[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.019Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mauto-advance can be cancelled by pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.031Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.039Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mauto-advance can be cancelled by pause
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:239:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2maudio playback does not count as a guess attempt
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902039-0.5084217766198549'[39m,
  timestamp: [35m2025-12-26T01:51:42.039Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mauto-advance can be cancelled by pause
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902032-0.5482169630279381'[39m,
  timestamp: [35m2025-12-26T01:51:42.032Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2maudio playback does not count as a guess attempt
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.026Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mincrements totalAttempts but not correctCount
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.019Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mincrements totalAttempts but not correctCount
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.036Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.028Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.044Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.028Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mincrements totalAttempts but not correctCount
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'G'[39m, isCorrect: [33mfalse[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902036-0.13737837831608934'[39m,
  timestamp: [35m2025-12-26T01:51:42.036Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending incorrect_guess to state machine
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m'Incorrect. Accuracy: 0.0% | Streak reset'[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902028-0.06599379767721891'[39m,
  timestamp: [35m2025-12-26T01:51:42.028Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902044-0.1790288800629276'[39m,
  timestamp: [35m2025-12-26T01:51:42.044Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902045-0.00395865232120296'[39m,
  timestamp: [35m2025-12-26T01:51:42.045Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902028-0.8756638074891572'[39m,
  timestamp: [35m2025-12-26T01:51:42.028Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902029-0.6756294844240256'[39m,
  timestamp: [35m2025-12-26T01:51:42.029Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.042Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mstays in waiting_input (sandbox allows retry)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/AudioActions.test.ts:33:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902042-0.9111572091855389'[39m,
  timestamp: [35m2025-12-26T01:51:42.042Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mstays in waiting_input (sandbox allows retry)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.039Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mstays in waiting_input (sandbox allows retry)
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'E'[39m, isCorrect: [33mfalse[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902039-0.20974103018070456'[39m,
  timestamp: [35m2025-12-26T01:51:42.039Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending incorrect_guess to state machine
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m'Incorrect. Accuracy: 0.0% | Streak reset'[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.029Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note cannot be called when paused (no current note in context)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.047Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note cannot be called when paused (no current note in context)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.031Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.041Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:239:7
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:26
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runTest (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1309:12)

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.030Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902047-0.10299903841146163'[39m,
  timestamp: [35m2025-12-26T01:51:42.047Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902047-0.4493136390715782'[39m,
  timestamp: [35m2025-12-26T01:51:42.047Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note cannot be called when paused (no current note in context)
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.045Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902041-0.8832400046769313'[39m,
  timestamp: [35m2025-12-26T01:51:42.041Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902041-0.9397715248209968'[39m,
  timestamp: [35m2025-12-26T01:51:42.041Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902030-0.43912024088970547'[39m,
  timestamp: [35m2025-12-26T01:51:42.030Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902030-0.9648112291440005'[39m,
  timestamp: [35m2025-12-26T01:51:42.030Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902031-0.571384049132911'[39m,
  timestamp: [35m2025-12-26T01:51:42.031Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called when completed (note still exists)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902045-0.5888862238791468'[39m,
  timestamp: [35m2025-12-26T01:51:42.045Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called when completed (note still exists)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.033Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called when completed (note still exists)
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.034Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [33m80[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [33m10[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.041Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.055Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.044Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:265:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902056-0.9541022255305187'[39m,
  timestamp: [35m2025-12-26T01:51:42.056Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902056-0.9721803684920296'[39m,
  timestamp: [35m2025-12-26T01:51:42.056Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.049Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902044-0.24137848129672346'[39m,
  timestamp: [35m2025-12-26T01:51:42.044Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902044-0.018488825181067536'[39m,
  timestamp: [35m2025-12-26T01:51:42.044Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902041-0.7525355328722212'[39m,
  timestamp: [35m2025-12-26T01:51:42.041Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.042Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.034Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [32mâœ“[39m src/game/events/AudioActions.test.ts [2m([22m[2m22 tests[22m[2m)[22m[32m 91[2mms[22m[39m
[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902049-0.9951309147954097'[39m,
  timestamp: [35m2025-12-26T01:51:42.049Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902049-0.5494083451403129'[39m,
  timestamp: [35m2025-12-26T01:51:42.049Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902050-0.5536898373834791'[39m,
  timestamp: [35m2025-12-26T01:51:42.050Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 33.3% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mmanual complete emits sessionComplete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:311:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mmanual complete emits sessionComplete
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902034-0.836616937619987'[39m,
  timestamp: [35m2025-12-26T01:51:42.034Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.036Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m, [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mmanual complete emits sessionComplete
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.044Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.046Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.062Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.052Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] submitGuess called: F
[Orchestrator] User submitted guess: F
[Orchestrator] Guess validation: { guessed: [32m'F'[39m, actual: [32m'F'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902047-0.8290833995045506'[39m,
  timestamp: [35m2025-12-26T01:51:42.047Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'F'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.040Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902062-0.6338188671249978'[39m,
  timestamp: [35m2025-12-26T01:51:42.062Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902062-0.5676400498792864'[39m,
  timestamp: [35m2025-12-26T01:51:42.062Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902052-0.719088939719003'[39m,
  timestamp: [35m2025-12-26T01:51:42.052Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.048Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.047Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:341:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902048-0.6971559792199806'[39m,
  timestamp: [35m2025-12-26T01:51:42.048Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:289:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902041-0.9967439258476809'[39m,
  timestamp: [35m2025-12-26T01:51:42.041Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902041-0.013060185816739178'[39m,
  timestamp: [35m2025-12-26T01:51:42.041Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.049Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902047-0.18370859174605392'[39m,
  timestamp: [35m2025-12-26T01:51:42.047Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.048Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902049-0.0020679527149380927'[39m,
  timestamp: [35m2025-12-26T01:51:42.049Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902049-0.7799023741331883'[39m,
  timestamp: [35m2025-12-26T01:51:42.049Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 66.7% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 50.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2memits stateChange to completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.066Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.054Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2memits stateChange to completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.045Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:308:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.055Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902055-0.9687529344978947'[39m,
  timestamp: [35m2025-12-26T01:51:42.055Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m, [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2memits stateChange to completed state
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.050Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.045Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902066-0.5740771723389924'[39m,
  timestamp: [35m2025-12-26T01:51:42.066Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902066-0.14439319536830264'[39m,
  timestamp: [35m2025-12-26T01:51:42.066Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.046Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.052Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:375:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.070Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902052-0.4036688476796628'[39m,
  timestamp: [35m2025-12-26T01:51:42.052Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902052-0.1809171812750876'[39m,
  timestamp: [35m2025-12-26T01:51:42.052Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.054Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902046-0.2757694301683715'[39m,
  timestamp: [35m2025-12-26T01:51:42.046Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902047-0.3150337748387917'[39m,
  timestamp: [35m2025-12-26T01:51:42.047Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.047Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m2[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [33m80[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [33m10[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m2[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902070-0.9908310001483693'[39m,
  timestamp: [35m2025-12-26T01:51:42.070Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902071-0.5740632074091157'[39m,
  timestamp: [35m2025-12-26T01:51:42.071Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mwarns when no current note (idle state)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:316:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mwarns when no current note (idle state)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902054-0.652336450387522'[39m,
  timestamp: [35m2025-12-26T01:51:42.054Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902056-0.8524924745009483'[39m,
  timestamp: [35m2025-12-26T01:51:42.056Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.057Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m2[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m2[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles multiple pause calls without errors
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.049Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles multiple pause calls without errors
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.060Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.055Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.074Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles multiple pause calls without errors
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902055-0.14254412292014695'[39m,
  timestamp: [35m2025-12-26T01:51:42.055Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902055-0.8144996444561154'[39m,
  timestamp: [35m2025-12-26T01:51:42.055Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mpausing from idle still emits stateChange
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902074-0.2444056825823251'[39m,
  timestamp: [35m2025-12-26T01:51:42.074Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mclears all timers on pause even if already cleared
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.060Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mpausing from idle still emits stateChange
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [1mnull[22m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: idle
[Orchestrator] Emitting event: stateChange { sessionState: [32m'idle'[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mclears all timers on pause even if already cleared
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.063Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902061-0.42191002466581073'[39m,
  timestamp: [35m2025-12-26T01:51:42.061Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mstate changes include both session and round context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mclears all timers on pause even if already cleared
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.061Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mstate changes include both session and round context
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles timer cancellation during rapid state changes
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902061-0.34558403883999933'[39m,
  timestamp: [35m2025-12-26T01:51:42.061Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.079Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles timer cancellation during rapid state changes
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.065Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.059Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.062Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902079-0.27237326810302775'[39m,
  timestamp: [35m2025-12-26T01:51:42.079Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902079-0.3535618742265869'[39m,
  timestamp: [35m2025-12-26T01:51:42.079Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles timer cancellation during rapid state changes
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:401:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902060-0.7858680837336156'[39m,
  timestamp: [35m2025-12-26T01:51:42.060Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:340:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.080Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles timer cancellation during rapid state changes
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902065-0.4597749383682137'[39m,
  timestamp: [35m2025-12-26T01:51:42.065Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902064-0.33778415324767574'[39m,
  timestamp: [35m2025-12-26T01:51:42.064Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 3'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.065Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m3[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m3[39m, longestStreak: [33m3[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m3[39m,
    totalAttempts: [33m3[39m,
    correctAttempts: [33m3[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.055Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:437:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902055-0.030283409505327263'[39m,
  timestamp: [35m2025-12-26T01:51:42.055Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.056Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.071Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.063Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.072Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.084Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902072-0.98803516794487'[39m,
  timestamp: [35m2025-12-26T01:51:42.072Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39m[Orchestrator] submitGuess called: F
[Orchestrator] User submitted guess: F
[Orchestrator] Guess validation: { guessed: [32m'F'[39m, actual: [32m'F'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902063-0.2640655059803543'[39m,
  timestamp: [35m2025-12-26T01:51:42.063Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'F'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39m[Orchestrator] submitGuess called: F
[Orchestrator] User submitted guess: F
[Orchestrator] Guess validation: { guessed: [32m'F'[39m, actual: [32m'F'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902084-0.10309835444829951'[39m,
  timestamp: [35m2025-12-26T01:51:42.084Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'F'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.073Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mstays in playing.waiting_input state after reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.062Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:431:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mstays in playing.waiting_input state after reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902074-0.7902920858628324'[39m,
  timestamp: [35m2025-12-26T01:51:42.074Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902074-0.18829456685320833'[39m,
  timestamp: [35m2025-12-26T01:51:42.074Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 50.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 33.3% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m, [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mstays in playing.waiting_input state after reset
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.079Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.087Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902079-0.4236528265580499'[39m,
  timestamp: [35m2025-12-26T01:51:42.079Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 50.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.080Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m50[39m,
    totalAttempts: [33m4[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m2[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m50[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m4[39m,
    correctAttempts: [33m2[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.067Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/1)'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.065Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902087-0.795032409637118'[39m,
  timestamp: [35m2025-12-26T01:51:42.087Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:439:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902067-0.8955381750979676'[39m,
  timestamp: [35m2025-12-26T01:51:42.067Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'ðŸŽ‰ Rush Mode Complete! 1/1 notes'[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mtrue[39m,
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'rush'[39m,
    timestamp: [35m2025-12-26T01:51:42.070Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: { targetNotes: [33m1[39m },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.076Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.065Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.088Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.resetGame (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:620:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:390:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.073Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902076-0.018396152953822353'[39m,
  timestamp: [35m2025-12-26T01:51:42.076Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902076-0.3604110952629369'[39m,
  timestamp: [35m2025-12-26T01:51:42.076Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902073-0.07088029881568803'[39m,
  timestamp: [35m2025-12-26T01:51:42.073Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902073-0.07700049707591461'[39m,
  timestamp: [35m2025-12-26T01:51:42.073Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902073-0.8205863030207929'[39m,
  timestamp: [35m2025-12-26T01:51:42.073Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 33.3% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/events/StateChangeActions.test.ts [2m([22m[2m22 tests[22m[2m)[22m[32m 113[2mms[22m[39m
[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.084Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.090Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m, [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.080Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.091Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.091Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.076Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from playing state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mcan start round even when completed (no state guards)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902076-0.7464868653763912'[39m,
  timestamp: [35m2025-12-26T01:51:42.076Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902077-0.23985104245472155'[39m,
  timestamp: [35m2025-12-26T01:51:42.077Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902077-0.9849225871084859'[39m,
  timestamp: [35m2025-12-26T01:51:42.077Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 3'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from playing state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mcan start round even when completed (no state guards)
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.093Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.086Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from playing state
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mcan start round even when completed (no state guards)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.093Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] submitGuess called: F
[Orchestrator] User submitted guess: F
[Orchestrator] Guess validation: { guessed: [32m'F'[39m, actual: [32m'F'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902087-0.8831105316508658'[39m,
  timestamp: [35m2025-12-26T01:51:42.087Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'F'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.089Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.098Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902089-0.10372838650071037'[39m,
  timestamp: [35m2025-12-26T01:51:42.089Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902090-0.43760637555340387'[39m,
  timestamp: [35m2025-12-26T01:51:42.090Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 50.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 33.3% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from completed state
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.085Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: idle
[Orchestrator] Emitting event: stateChange { sessionState: [32m'idle'[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902099-0.1930579414307214'[39m,
  timestamp: [35m2025-12-26T01:51:42.099Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

 [32mâœ“[39m src/game/events/GuessActions.test.ts [2m([22m[2m20 tests[22m[2m)[22m[32m 122[2mms[22m[39m
[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.100Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould count down session timer over time
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m, [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902100-0.15744647798657319'[39m,
  timestamp: [35m2025-12-26T01:51:42.100Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.087Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.101Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:443:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould count down session timer over time
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.143Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] submitGuess called: F
[Orchestrator] User submitted guess: F
[Orchestrator] Guess validation: { guessed: [32m'F'[39m, actual: [32m'F'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902101-0.8365595882502568'[39m,
  timestamp: [35m2025-12-26T01:51:42.101Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'F'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 3'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.092Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902087-0.32021291300520116'[39m,
  timestamp: [35m2025-12-26T01:51:42.087Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.088Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.093Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.095Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.104Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902095-0.7238845003173426'[39m,
  timestamp: [35m2025-12-26T01:51:42.095Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902096-0.6482419838191231'[39m,
  timestamp: [35m2025-12-26T01:51:42.096Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] submitGuess called: D
[Orchestrator] User submitted guess: D
[Orchestrator] Guess validation: { guessed: [32m'D'[39m, actual: [32m'D'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902105-0.24119158763528814'[39m,
  timestamp: [35m2025-12-26T01:51:42.105Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'D'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.096Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.106Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902097-0.03336672530047213'[39m,
  timestamp: [35m2025-12-26T01:51:42.097Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902097-0.1792372357619043'[39m,
  timestamp: [35m2025-12-26T01:51:42.097Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.091Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.098Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'F'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:443:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902091-0.76252912852581'[39m,
  timestamp: [35m2025-12-26T01:51:42.091Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.092Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.108Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902109-0.38164886017971766'[39m,
  timestamp: [35m2025-12-26T01:51:42.109Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.099Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.109Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:556:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902110-0.1840183724689204'[39m,
  timestamp: [35m2025-12-26T01:51:42.110Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902100-0.8988743207991596'[39m,
  timestamp: [35m2025-12-26T01:51:42.100Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902100-0.19945655822385278'[39m,
  timestamp: [35m2025-12-26T01:51:42.100Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.110Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.096Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902110-0.8555620216796258'[39m,
  timestamp: [35m2025-12-26T01:51:42.110Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 3'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.102Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:443:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902102-0.8444870880746425'[39m,
  timestamp: [35m2025-12-26T01:51:42.102Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] submitGuess called: A
[Orchestrator] User submitted guess: A
[Orchestrator] Guess validation: { guessed: [32m'A'[39m, actual: [32m'A'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902096-0.34999100357523383'[39m,
  timestamp: [35m2025-12-26T01:51:42.096Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'A'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.097Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.103Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:574:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902104-0.0824541040164295'[39m,
  timestamp: [35m2025-12-26T01:51:42.104Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902104-0.5512908087197939'[39m,
  timestamp: [35m2025-12-26T01:51:42.104Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 50.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 33.3% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m, [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.105Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m33.33333333333333[39m,
    totalAttempts: [33m3[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m33.33333333333333[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m3[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/events/RoundFlowActions.test.ts [2m([22m[2m27 tests[22m[2m)[22m[32m 163[2mms[22m[39m
[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.101Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [32mâœ“[39m src/game/events/EdgeCaseActions.test.ts [2m([22m[2m26 tests[22m[2m)[22m[32m 159[2mms[22m[39m
[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:443:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] submitGuess called: E
[Orchestrator] User submitted guess: E
[Orchestrator] Guess validation: { guessed: [32m'E'[39m, actual: [32m'E'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902102-0.40082303943466857'[39m,
  timestamp: [35m2025-12-26T01:51:42.102Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'E'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.102Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.105Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:443:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] submitGuess called: B
[Orchestrator] User submitted guess: B
[Orchestrator] Guess validation: { guessed: [32m'B'[39m, actual: [32m'B'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902105-0.44291209335560855'[39m,
  timestamp: [35m2025-12-26T01:51:42.105Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'B'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'B'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.107Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.startGame (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:575:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:501:20
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:26
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runTest (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1309:12)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.111Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:532:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902112-0.7721315785325857'[39m,
  timestamp: [35m2025-12-26T01:51:42.112Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.113Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m1[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m1[39m, longestStreak: [33m1[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m1[39m,
    totalAttempts: [33m1[39m,
    correctAttempts: [33m1[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.121Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'C'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C
[Orchestrator] Guess validation: { guessed: [32m'C'[39m, actual: [32m'C'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902121-0.7192703955116739'[39m,
  timestamp: [35m2025-12-26T01:51:42.121Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'C'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 1'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.123Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:559:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] submitGuess called: G
[Orchestrator] User submitted guess: G
[Orchestrator] Guess validation: { guessed: [32m'G'[39m, actual: [32m'G'[39m, isCorrect: [33mtrue[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766713902124-0.6584813013171547'[39m,
  timestamp: [35m2025-12-26T01:51:42.124Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: { note: [32m'G'[39m, octave: [33m4[39m },
  isCorrect: [33mtrue[39m
}
[Orchestrator] Sending MAKE_GUESS to state machine
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] State changed: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed to: playing -> processing_guess
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending correct_guess to state machine
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mtrue[39m,
  feedback: [32m'Correct! Accuracy: 100.0% | Streak: 2'[39m,
  shouldAdvance: [33mtrue[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling auto-advance in [33m1000[39m ms
[Orchestrator] Clearing timer: advance-after-correct
[Orchestrator] Scheduling timer: advance-after-correct delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-correct'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:42.127Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m2[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m2[39m, longestStreak: [33m2[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m2[39m,
    totalAttempts: [33m2[39m,
    correctAttempts: [33m2[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:45:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

 [31mâ¯[39m src/game/events/SessionActions.test.ts [2m([22m[2m32 tests[22m[2m | [22m[31m1 failed[39m[2m)[22m[32m 174[2mms[22m[39m
       [32mâœ“[39m emits stateChange event when transitioning from idle to playing[32m 12[2mms[22m[39m
       [32mâœ“[39m transitions to playing.waiting_input state[32m 5[2mms[22m[39m
       [32mâœ“[39m clears all active timers before starting[32m 4[2mms[22m[39m
       [32mâœ“[39m can be called from idle state[32m 2[2mms[22m[39m
       [32mâœ“[39m emits stateChange to paused when pause() called[32m 2[2mms[22m[39m
       [32mâœ“[39m clears all active timers on pause[32m 8[2mms[22m[39m
       [32mâœ“[39m can pause from waiting_input state[32m 11[2mms[22m[39m
       [32mâœ“[39m can pause from timeout_intermission state[32m 3[2mms[22m[39m
       [32mâœ“[39m emits stateChange returning to previous round state[32m 4[2mms[22m[39m
       [32mâœ“[39m preserves stats across pause/resume[32m 6[2mms[22m[39m
       [32mâœ“[39m preserves current note across pause/resume[32m 4[2mms[22m[39m
       [32mâœ“[39m returns to waiting_input after resume from waiting_input pause[32m 10[2mms[22m[39m
       [32mâœ“[39m returns to timeout_intermission after resume from intermission pause[32m 4[2mms[22m[39m
       [32mâœ“[39m transitions to completed state[32m 11[2mms[22m[39m
       [32mâœ“[39m manual complete emits sessionComplete[32m 2[2mms[22m[39m
       [32mâœ“[39m stats remain accessible after completion[32m 4[2mms[22m[39m
       [32mâœ“[39m emits stateChange to completed state[32m 3[2mms[22m[39m
       [32mâœ“[39m clears all active timers on complete[32m 7[2mms[22m[39m
[31m       [31mÃ—[31m calculates accuracy correctly via getStats[39m[32m 11[2mms[22m[39m
       [32mâœ“[39m emits feedbackUpdate with initial message on reset[32m 3[2mms[22m[39m
       [32mâœ“[39m stays in playing.waiting_input state after reset[32m 2[2mms[22m[39m
       [32mâœ“[39m clears all timers on reset[32m 4[2mms[22m[39m
       [32mâœ“[39m clears current note on reset[32m 3[2mms[22m[39m
       [32mâœ“[39m can reset from playing state[32m 2[2mms[22m[39m
       [32mâœ“[39m can reset from completed state[32m 2[2mms[22m[39m
       [32mâœ“[39m emits stateChange to playing.waiting_input[32m 4[2mms[22m[39m
       [32mâœ“[39m resets orchestrator stats to 0[32m 5[2mms[22m[39m
       [32mâœ“[39m preserves game mode settings[32m 4[2mms[22m[39m
       [32mâœ“[39m clears all timers before transitioning[32m 5[2mms[22m[39m
       [32mâœ“[39m can only be called from completed state[32m 6[2mms[22m[39m
       [32mâœ“[39m completes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again[32m 7[2mms[22m[39m
       [32mâœ“[39m preserves stats through pause/resume but resets on play again[32m 12[2mms[22m[39m
[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould initialize timer to responseTimeLimit value
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould initialize timer to responseTimeLimit value
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.253Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould call onTimeUpdate callback during countdown
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould call onTimeUpdate callback during countdown
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.409Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'E'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during processing_guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves all stats across multiple pauses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTarget Variations[2m > [22m[2mcompletes with minimal target (3 notes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTarget Variations[2m > [22m[2mcompletes with medium target (5 notes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTarget Variations[2m > [22m[2mcompletes with larger target and errors (10 notes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mcompletes after many incorrect attempts
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mresets stats on play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/RushMode.test.ts [2m([22m[2m17 tests[22m[2m)[22m[33m 598[2mms[22m[39m
       [33m[2mâœ“[22m[39m timer continues until completion [33m 335[2mms[22m[39m
[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mgame completes automatically when timer reaches 0
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould show correct time after specific duration
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould show correct time after specific duration
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.878Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould pause timer when game is paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould pause timer when game is paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:42.928Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould pause timer when game is paused
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mgame completes automatically when timer reaches 0
[22m[39m[gameStateMachine] TIMEOUT event received - transitioning to COMPLETED
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state (applySettings) - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:43.419Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m0.008333333333333333[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould pause session timer when game is paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould pause session timer when game is paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:43.656Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'D'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves stats across multiple pauses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPlay Again[2m > [22m[2mresets stats on play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:51:43.673Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m3[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [33m3[39m
    },
    results: { notesCompleted: [33m3[39m, longestStreak: [33m3[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m3[39m,
    totalAttempts: [33m3[39m,
    correctAttempts: [33m3[39m
  }
}
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstderr[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPlay Again[2m > [22m[2mresets stats on play again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/SandboxMode.test.ts:19:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPlay Again[2m > [22m[2mresets stats on play again
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

 [32mâœ“[39m src/game/SandboxMode.test.ts [2m([22m[2m14 tests[22m[2m)[22m[33m 1800[2mms[22m[39m
       [33m[2mâœ“[22m[39m timer configuration is passed correctly for countdown mode [33m 683[2mms[22m[39m
       [33m[2mâœ“[22m[39m game completes automatically when timer reaches 0 [33m 999[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:43.734Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'A'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/GameStateInterfaceCompliance.test.tsx [2m([22m[2m64 tests[22m[2m)[22m[32m 13[2mms[22m[39m
 [32mâœ“[39m src/game/strategies/EarTrainingStrategy.test.ts [2m([22m[2m30 tests[22m[2m)[22m[32m 17[2mms[22m[39m
 [32mâœ“[39m src/game/ModeRegistry.test.ts [2m([22m[2m6 tests[22m[2m)[22m[32m 90[2mms[22m[39m
[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould pause session timer when game is paused
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

 [32mâœ“[39m src/utils/chordValidation.test.ts [2m([22m[2m46 tests[22m[2m)[22m[32m 15[2mms[22m[39m
[90mstdout[2m | src/machines/gameStateMachine.test.ts[2m > [22m[2mGame State Machine[2m > [22m[2mTimer Behavior[2m > [22m[2mshould transition to COMPLETED when TIMEOUT event is received
[22m[39m[gameStateMachine] TIMEOUT event received - transitioning to COMPLETED

[90mstdout[2m | src/machines/gameStateMachine.test.ts[2m > [22m[2mGame State Machine[2m > [22m[2mTimer Behavior[2m > [22m[2mshould transition to COMPLETED from any round state on TIMEOUT
[22m[39m[gameStateMachine] TIMEOUT event received - transitioning to COMPLETED

 [32mâœ“[39m src/machines/gameStateMachine.test.ts [2m([22m[2m27 tests[22m[2m)[22m[32m 26[2mms[22m[39m
 [32mâœ“[39m src/machines/services/timerService.test.ts [2m([22m[2m8 tests[22m[2m)[22m[32m 44[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

 [32mâœ“[39m src/machines/roundTimer.test.ts [2m([22m[2m15 tests[22m[2m)[22m[32m 41[2mms[22m[39m
 [32mâœ“[39m src/game/ChordIdentificationGameState.test.ts [2m([22m[2m14 tests[22m[2m)[22m[32m 12[2mms[22m[39m
 [32mâœ“[39m src/game/strategies/ChordTrainingStrategy.test.ts [2m([22m[2m41 tests[22m[2m)[22m[32m 19[2mms[22m[39m
[90mstderr[2m | src/game/GameStateFactory.test.tsx[2m > [22m[2mGameStateFactory[2m > [22m[2mFallback Behavior[2m > [22m[2mshould fallback to sandbox for unknown mode
[22m[39mUnknown mode: unknown-mode, falling back to sandbox

 [32mâœ“[39m src/game/GameStateFactory.test.tsx [2m([22m[2m18 tests[22m[2m)[22m[32m 14[2mms[22m[39m
 [32mâœ“[39m src/game/SingleChordGameState.test.ts [2m([22m[2m14 tests[22m[2m)[22m[32m 9[2mms[22m[39m
 [32mâœ“[39m src/utils/chordInversions.test.ts [2m([22m[2m21 tests[22m[2m)[22m[32m 9[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] User pressed unpause
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameResumed [90mundefined[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:44.388Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'G'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:51:44.670Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  note: { note: [32m'B'[39m, octave: [33m4[39m },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

 [32mâœ“[39m src/game/ChordIdentificationTimerMethods.test.ts [2m([22m[2m14 tests[22m[2m)[22m[32m 6[2mms[22m[39m
[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] User pressed unpause
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameResumed [90mundefined[39m

 [32mâœ“[39m src/components/NoteIdentification.test.tsx [2m([22m[2m8 tests[22m[2m)[22m[32m 5[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] User pressed unpause
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameResumed [90mundefined[39m

 [32mâœ“[39m src/game/SessionTimerBehavior.test.ts [2m([22m[2m5 tests[22m[2m)[22m[33m 3388[2mms[22m[39m
     [33m[2mâœ“[22m[39m should count down session timer over time [33m 735[2mms[22m[39m
     [33m[2mâœ“[22m[39m should show correct time after specific duration [33m 778[2mms[22m[39m
     [33m[2mâœ“[22m[39m should pause session timer when game is paused [33m 733[2mms[22m[39m
     [33m[2mâœ“[22m[39m should resume session timer when game is resumed [33m 930[2mms[22m[39m
 [31mâ¯[39m src/game/TimerBehavior.test.ts [2m([22m[2m6 tests[22m[2m | [22m[31m1 failed[39m[2m)[22m[33m 3516[2mms[22m[39m
     [33m[2mâœ“[22m[39m should start timer countdown when round begins [33m 322[2mms[22m[39m
     [32mâœ“[39m should initialize timer to responseTimeLimit value[32m 156[2mms[22m[39m
     [33m[2mâœ“[22m[39m should call onTimeUpdate callback during countdown [33m 519[2mms[22m[39m
     [33m[2mâœ“[22m[39m should pause timer when game is paused [33m 781[2mms[22m[39m
     [33m[2mâœ“[22m[39m should resume timer when game is resumed [33m 962[2mms[22m[39m
[31m     [31mÃ—[31m should preserve timer value across pause/resume cycle[39m[33m 776[2mms[22m[39m

[31mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[39m[1m[41m Failed Tests 2 [49m[22m[31mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[39m

[41m[1m FAIL [22m[49m src/game/TimerBehavior.test.ts[2m > [22mTimer Behavior[2m > [22mshould preserve timer value across pause/resume cycle
[31m[1mAssertionError[22m: expected 2.100000000000001 to be less than 1[39m
[36m [2mâ¯[22m src/game/TimerBehavior.test.ts:[2m239:59[22m[39m
    [90m237| [39m      [90m// Timer should have continued from approximately where it paused[39m
    [90m238| [39m      // (within 1 second tolerance for async delays and floating poinâ€¦
    [90m239| [39m      expect(Math.abs(timeAfterResume - timeBeforePause)).toBeLessThanâ€¦
    [90m   | [39m                                                          [31m^[39m
    [90m240| [39m    }
    [90m241| [39m  })[33m;[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[1/2]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mComplete Game[2m > [22mcalculates accuracy correctly via getStats
[31m[1mAssertionError[22m: expected 3 to be 2 // Object.is equality[39m

[32m- Expected[39m
[31m+ Received[39m

[32m- 2[39m
[31m+ 3[39m

[36m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m345:34[22m[39m
    [90m343| [39m      [35mconst[39m stats [33m=[39m orchestrator[33m.[39m[34mgetStats[39m()[33m;[39m
    [90m344| [39m      [34mexpect[39m(stats[33m.[39mtotalAttempts)[33m.[39m[34mtoBe[39m([34m3[39m)[33m;[39m
    [90m345| [39m      [34mexpect[39m(stats[33m.[39mcorrectCount)[33m.[39m[34mtoBe[39m([34m2[39m)[33m;[39m
    [90m   | [39m                                 [31m^[39m
    [90m346| [39m
    [90m347| [39m      const accuracy = (stats.correctCount / stats.totalAttempts) * 10â€¦

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[2/2]âŽ¯[22m[39m


[2m Test Files [22m [1m[31m2 failed[39m[22m[2m | [22m[1m[32m27 passed[39m[22m[90m (29)[39m
[2m      Tests [22m [1m[31m2 failed[39m[22m[2m | [22m[1m[32m640 passed[39m[22m[2m | [22m[33m3 skipped[39m[90m (645)[39m
[2m   Start at [22m 20:51:38
[2m   Duration [22m 6.54s[2m (transform 9.64s, setup 32.77s, collect 3.51s, tests 10.82s, environment 25.51s, prepare 841ms)[22m

