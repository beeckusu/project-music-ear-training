
> music-practice-app@0.0.0 test
> vitest --run


[1m[46m RUN [49m[22m [36mv4.0.9 [39m[90mC:/Users/gavin/repos/meta[39m

 [31mâ¯[39m src/game/ModeRegistry.test.ts [2m([22m[2m6 tests[22m[2m | [22m[31m2 failed[39m[2m)[22m[32m 30[2mms[22m[39m
     [32mâœ“[39m should throw error when registering mode without strategyType[32m 2[2mms[22m[39m
     [32mâœ“[39m should successfully register mode with valid strategyType[32m 1[2mms[22m[39m
[31m     [31mÃ—[31m should have all expected modes registered[39m[32m 19[2mms[22m[39m
[31m     [31mÃ—[31m should filter modes by type correctly[39m[32m 3[2mms[22m[39m
     [32mâœ“[39m should create valid game states from registered modes[32m 3[2mms[22m[39m
     [32mâœ“[39m should have valid strategyType for all registered modes[32m 1[2mms[22m[39m
 [31mâ¯[39m src/components/PianoKeyboard.test.tsx [2m([22m[2m4 tests[22m[2m | [22m[31m4 failed[39m[2m)[22m[32m 31[2mms[22m[39m
[31m     [31mÃ—[31m should release all notes before playing new note when monoMode is true[39m[32m 22[2mms[22m[39m
[31m     [31mÃ—[31m should NOT release notes before playing when monoMode is false[39m[32m 5[2mms[22m[39m
[31m     [31mÃ—[31m should highlight notes with error type in red[39m[32m 2[2mms[22m[39m
[31m     [31mÃ—[31m should have preventNoteRestart prop available[39m[32m 1[2mms[22m[39m
 [32mâœ“[39m src/utils/chordEngine.test.ts [2m([22m[2m81 tests[22m[2m)[22m[32m 32[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould start timer countdown when round begins
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould initialize session timer to configured duration
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould start timer countdown when round begins
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.493Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mstarts with full health
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould initialize session timer to configured duration
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.495Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.487Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mBasic Rush Flow[2m > [22m[2mcompletes when target notes reached
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mrecovers health on correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Notes Tracking[2m > [22m[2mtracks progress toward targetNotes but does not complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mcaps health at maxHealth
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710934487-0.538022051941589'[39m,
  timestamp: [35m2025-12-26T01:02:14.487Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mHealth System[2m > [22m[2mloses health on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mBasic Rush Flow[2m > [22m[2mhandles mixed correct/incorrect guesses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Notes Tracking[2m > [22m[2mcontinues beyond target with mixed correct/incorrect
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mGame Over Conditions[2m > [22m[2mcompletes when health reaches zero
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mIDLE â†’ PLAYING: startGame()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2memits stateChange event when transitioning from idle to playing
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Accuracy Tracking[2m > [22m[2mtracks accuracy toward target but does not complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mGame Over Conditions[2m > [22m[2mallows multiple incorrect guesses before death
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mIDLE â†’ PLAYING: startGame()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange event when entering TIMEOUT_INTERMISSION
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Accuracy Tracking[2m > [22m[2mcontinues even with 100% accuracy on first guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2memits stateChange event when transitioning from idle to playing
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes NOT emit any orchestrator events
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mGame Over Conditions[2m > [22m[2mcontinues game with correct guesses maintaining health
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mbuilds and maintains streak
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2memits roundStart with generated note and feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Streak Tracking[2m > [22m[2mtracks streak toward target but does not complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mtransitions to playing.waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes NOT emit any orchestrator events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.522Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.515Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mbuilds streak with correct guesses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2memits roundStart with generated note and feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.524Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessAttempt event with correct payload for correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.525Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mTarget Streak Tracking[2m > [22m[2mrequires consecutive correct guesses for streak
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'A4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mtransitions to playing.waiting_input state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mmaintains current state after replay
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710934515-0.7259057157959179'[39m,
  timestamp: [35m2025-12-26T01:02:14.515Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mMultiple Targets[2m > [22m[2mcontinues when one target is met but not others
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mclears all active timers before starting
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.527Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mmaintains current state after replay
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.529Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStreak Tracking[2m > [22m[2mresets streak on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2memits guessResult event with isCorrect: true
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.535Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2mprocesses all rapid guess submissions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.540Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mgenerates note using configured note filter
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mMultiple Targets[2m > [22m[2mallows practice when no targets set
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mclears all active timers before starting
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ PAUSED: pause()
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not change current note
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mstateChange event emission[2m > [22m[2mshould emit stateChange events even after applySettings recreates actor
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mStats Tracking[2m > [22m[2mtracks correct and incorrect attempts
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mgenerates note using configured note filter
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.543Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mdoes not complete when targets are met (only timer expiration completes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mcan be called from idle state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not change current note
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.532Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mupdates stats correctly on correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.538Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2msubsequent guesses processed but state machine may ignore
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.549Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mtimer configuration is passed correctly for countdown mode
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mStart Game[2m > [22m[2mcan be called from idle state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not affect stats
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.523Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves stats across multiple pauses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.545Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2memits stateChange to paused when pause() called
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.531Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mdoes not affect stats
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.534Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710934523-0.3801862701102223'[39m,
  timestamp: [35m2025-12-26T01:02:14.523Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mprevents health from going negative
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.541Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Guess Submissions[2m > [22m[2monly first guess counts in stats (subsequent ignored by state machine)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.552Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcalls game mode onStartNewRound callback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2memits stateChange to paused when pause() called
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPAUSED â†’ PLAYING: resume()
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called multiple times
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2msurvives with 1 HP remaining
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcalls game mode onStartNewRound callback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.548Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2memits stateChange to paused when pause() called
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ COMPLETED: complete()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called multiple times
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.536Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould not break stateChange emission when actor is recreated
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/SurvivalMode.test.ts[2m > [22m[2mSurvival Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mhandles rapid health fluctuations
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'G4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mCorrect Guess Events[2m > [22m[2mincrements currentStreak on correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.544Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.554Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from idle state (first round)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mPLAYING â†’ COMPLETED: complete()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.539Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called from waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessAttempt event with isCorrect: false
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from idle state (first round)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ IDLE: reset()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mcan be called from waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.538Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.530Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessAttempt event with isCorrect: false
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.546Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2memits stateChange for each pause/resume
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from idle state (first round)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.551Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [32mâœ“[39m src/game/SurvivalMode.test.ts [2m([22m[2m16 tests[22m[2m)[22m[32m 66[2mms[22m[39m
[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.537Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ IDLE: reset()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.542Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: idle
[Orchestrator] Emitting event: stateChange { sessionState: [32m'idle'[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mlogs warning if no current note exists
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710934530-0.9291428576020015'[39m,
  timestamp: [35m2025-12-26T01:02:14.530Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessResult event with incorrect feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2memits stateChange for each pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.560Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:134:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mlogs warning if no current note exists
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.540Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.timeout.test.ts:71:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2memits guessResult event with incorrect feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.548Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2memits stateChange for each pause/resume
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.554Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mclears all active timers on pause
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931538-0.5497326267741458'[39m,
  timestamp: [35m2025-12-26T01:02:11.538Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931538-0.7450436652022523'[39m,
  timestamp: [35m2025-12-26T01:02:11.538Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.545Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mReplay Note (Pure Audio Action)[2m > [22m[2mlogs warning if no current note exists
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/GameOrchestrator.timeout.test.ts[2m > [22m[2mGameOrchestrator - Timeout Intermission[2m > [22m[2mRegression protection[2m > [22m[2mshould emit stateChange from BOTH start() and applySettings() subscriptions
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mpreserves state through rapid cycles
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931554-0.4880913885267699'[39m,
  timestamp: [35m2025-12-26T01:02:11.554Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931555-0.5596719318483527'[39m,
  timestamp: [35m2025-12-26T01:02:11.555Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart event with note
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mresets current streak to 0 on incorrect guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.549Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mRapid Pause/Resume Cycles[2m > [22m[2mpreserves state through rapid cycles
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.571Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.556Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession State Transitions[2m > [22m[2mCOMPLETED â†’ PLAYING: playAgain()
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart event with note
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.543Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mincrements totalAttempts but not correctCount
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.546Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mplays audio for the generated note
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/GameOrchestrator.timeout.test.ts [2m([22m[2m7 tests[22m[2m | [22m[33m3 skipped[39m[2m)[22m[32m 59[2mms[22m[39m
[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mincrements totalAttempts but not correctCount
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.551Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.573Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mcan start from timeout_intermission state
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from waiting_input state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mplays audio for the generated note
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.549Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mstays in waiting_input (sandbox allows retry)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:166:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mfeedback message is mode-specific
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.560Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mIncorrect Guess Events[2m > [22m[2mstays in waiting_input (sandbox allows retry)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.555Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mpreserves intermission state when paused
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931573-0.6880966069719374'[39m,
  timestamp: [35m2025-12-26T01:02:11.573Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931573-0.5624844276627998'[39m,
  timestamp: [35m2025-12-26T01:02:11.573Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mfeedback message is mode-specific
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.561Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.551Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mroundStart includes context with note for ear training
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.548Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.552Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.557Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.580Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Start[2m > [22m[2mroundStart includes context with note for ear training
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.563Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:159:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.563Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mgenerates new note for each round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.552Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931558-0.5997920015136433'[39m,
  timestamp: [35m2025-12-26T01:02:11.558Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931558-0.13813514250571024'[39m,
  timestamp: [35m2025-12-26T01:02:11.558Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:185:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPause Game[2m > [22m[2mcan pause from timeout_intermission state
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931548-0.38432142874320796'[39m,
  timestamp: [35m2025-12-26T01:02:11.548Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931548-0.12216525761943142'[39m,
  timestamp: [35m2025-12-26T01:02:11.548Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart with mode-specific feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mclears auto-advance timer when pausing during intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931580-0.9181712772731434'[39m,
  timestamp: [35m2025-12-26T01:02:11.580Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931581-0.5530184425546498'[39m,
  timestamp: [35m2025-12-26T01:02:11.581Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mschedules auto-advance timer after correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.571Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2memits roundStart with mode-specific feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.554Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2memits guessAttempt with guessedNote: null on timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.568Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.585Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mcan manually advance after correct guess
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.573Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.552Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931569-0.06535818662981274'[39m,
  timestamp: [35m2025-12-26T01:02:11.569Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931569-0.0037793560429904005'[39m,
  timestamp: [35m2025-12-26T01:02:11.569Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mInitial Note Playback (via startNewRound)[2m > [22m[2mtransitions to waiting_input state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.557Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.562Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:206:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mdoes NOT emit any events when note duration changed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931562-0.5485164391121833'[39m,
  timestamp: [35m2025-12-26T01:02:11.562Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931563-0.21821146791467494'[39m,
  timestamp: [35m2025-12-26T01:02:11.563Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mPause During Intermission[2m > [22m[2mcan pause and resume multiple times during intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931585-0.6913804688763359'[39m,
  timestamp: [35m2025-12-26T01:02:11.585Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931585-0.13931919136223136'[39m,
  timestamp: [35m2025-12-26T01:02:11.585Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mclears previous auto-advance timer if called again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.575Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2memits stateChange returning to previous round state
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mWAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mdoes NOT change state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mauto-advance can be cancelled by pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mstores duration for next playback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mreveals correct note in feedback message
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2memits events in correct order for guess flow
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.594Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Correct Guess[2m > [22m[2mauto-advance can be cancelled by pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.580Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mNote Duration Changes[2m > [22m[2mcan be changed multiple times
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.556Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.573Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mresets streak to 0 on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.565Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mstateChange always precedes dependent events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.596Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.582Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931573-0.8016656089223846'[39m,
  timestamp: [35m2025-12-26T01:02:11.573Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931573-0.5602251318305691'[39m,
  timestamp: [35m2025-12-26T01:02:11.573Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplayNote is pure audio, startNewRound emits events
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.564Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931582-0.038466476314872766'[39m,
  timestamp: [35m2025-12-26T01:02:11.582Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931583-0.39668290792570904'[39m,
  timestamp: [35m2025-12-26T01:02:11.583Z[39m,
  actualNote: { note: [32m'C'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was C. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves stats across pause/resume
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:41:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.571Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Order Verification[2m > [22m[2mno duplicate event emissions for single action
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.598Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mTIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2mreplay does not interfere with game state or flow
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.569Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931571-0.8615145436930538'[39m,
  timestamp: [35m2025-12-26T01:02:11.571Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931572-0.4761741664797068'[39m,
  timestamp: [35m2025-12-26T01:02:11.572Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mschedules auto-advance timer after timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2maudio playback does not count as a guess attempt
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.599Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.559Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio vs Event Separation[2m > [22m[2maudio playback does not count as a guess attempt
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.572Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mschedules auto-advance to next round
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931599-0.3853925396019853'[39m,
  timestamp: [35m2025-12-26T01:02:11.599Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931600-0.8095061533620969'[39m,
  timestamp: [35m2025-12-26T01:02:11.600Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.585Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mpreserves current note across pause/resume
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.576Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931585-0.3363304815492252'[39m,
  timestamp: [35m2025-12-26T01:02:11.585Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931585-0.3640192345740836'[39m,
  timestamp: [35m2025-12-26T01:02:11.585Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes sessionState in all transitions
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.574Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.574Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when in timeout_intermission
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931574-0.018773416127420672'[39m,
  timestamp: [35m2025-12-26T01:02:11.574Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931574-0.08019108810545039'[39m,
  timestamp: [35m2025-12-26T01:02:11.574Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931574-0.7940058821076503'[39m,
  timestamp: [35m2025-12-26T01:02:11.574Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931574-0.8019648401945549'[39m,
  timestamp: [35m2025-12-26T01:02:11.574Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mdelay is capped at 2 seconds for timeout auto-advance
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.563Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/AudioActions.test.ts:33:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.602Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2mincludes roundState for round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.592Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called during timeout_intermission
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mTimeout Events (No Guess)[2m > [22m[2mincrements totalAttempts on timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when paused
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.590Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to waiting_input after resume from waiting_input pause
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note cannot be called when paused (no current note in context)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931590-0.9767410640116105'[39m,
  timestamp: [35m2025-12-26T01:02:11.590Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931591-0.158178278255672'[39m,
  timestamp: [35m2025-12-26T01:02:11.591Z[39m,
  actualNote: { note: [32m'D'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was D. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note cannot be called when paused (no current note in context)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.582Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.581Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.605Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mstateChange Event Payloads[2m > [22m[2msession state remains "playing" during round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.595Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note cannot be called when paused (no current note in context)
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guess even when completed
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.605Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2msends ADVANCE_ROUND action after delay
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.566Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called when completed (note still exists)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2mdoes not emit sessionComplete for normal guesses
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.582Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mwarns when no current note (idle state)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called when completed (note still exists)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.585Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mwarns when no current note (idle state)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] submitGuess called: C
[Orchestrator] User submitted guess: C

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.593Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:239:7
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:26
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runTest (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1309:12)

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2memits all state changes in correct order for full game flow
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.597Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/AudioActions.test.ts[2m > [22m[2mAudio Actions: Events[2m > [22m[2mAudio Action Edge Cases[2m > [22m[2mreplay note can be called when completed (note still exists)
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.586Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [33m80[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [33m10[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931594-0.5990516945605746'[39m,
  timestamp: [35m2025-12-26T01:02:11.594Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931594-0.6445273584133371'[39m,
  timestamp: [35m2025-12-26T01:02:11.594Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mResume Game[2m > [22m[2mreturns to timeout_intermission after resume from intermission pause
[22m[39m[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931567-0.4476874970827809'[39m,
  timestamp: [35m2025-12-26T01:02:11.567Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931567-0.48788651513613956'[39m,
  timestamp: [35m2025-12-26T01:02:11.567Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mEvent Order and Timing[2m > [22m[2memits sessionComplete when guess completes game
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.585Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/1)'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles multiple pause calls without errors
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles multiple pause calls without errors
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.610Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mcan manually advance after timeout
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.599Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.587Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [31mâ¯[39m src/game/events/AudioActions.test.ts [2m([22m[2m22 tests[22m[2m | [22m[31m5 failed[39m[2m)[22m[32m 82[2mms[22m[39m
       [32mâœ“[39m does NOT emit any orchestrator events[32m 19[2mms[22m[39m
       [32mâœ“[39m maintains current state after replay[32m 5[2mms[22m[39m
       [32mâœ“[39m does not change current note[32m 2[2mms[22m[39m
       [32mâœ“[39m does not affect stats[32m 2[2mms[22m[39m
       [32mâœ“[39m can be called multiple times[32m 2[2mms[22m[39m
       [32mâœ“[39m can be called from waiting_input state[32m 2[2mms[22m[39m
       [32mâœ“[39m logs warning if no current note exists[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m emits roundStart event with note[39m[32m 5[2mms[22m[39m
[31m       [31mÃ—[31m plays audio for the generated note[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m generates new note for each round[39m[32m 3[2mms[22m[39m
       [32mâœ“[39m emits roundStart with mode-specific feedback[32m 3[2mms[22m[39m
       [32mâœ“[39m transitions to waiting_input state[32m 2[2mms[22m[39m
       [32mâœ“[39m does NOT emit any events when note duration changed[32m 2[2mms[22m[39m
       [32mâœ“[39m does NOT change state[32m 1[2mms[22m[39m
       [32mâœ“[39m stores duration for next playback[32m 1[2mms[22m[39m
       [32mâœ“[39m can be changed multiple times[32m 1[2mms[22m[39m
[31m       [31mÃ—[31m replayNote is pure audio, startNewRound emits events[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m replay does not interfere with game state or flow[39m[32m 3[2mms[22m[39m
       [32mâœ“[39m audio playback does not count as a guess attempt[32m 2[2mms[22m[39m
       [32mâœ“[39m replay note can be called during timeout_intermission[32m 4[2mms[22m[39m
       [32mâœ“[39m replay note cannot be called when paused (no current note in context)[32m 7[2mms[22m[39m
       [32mâœ“[39m replay note can be called when completed (note still exists)[32m 4[2mms[22m[39m
[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles multiple pause calls without errors
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mtransitions to completed state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.572Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at pauseGame (C:/Users/gavin/repos/meta/src/test/gameTestUtils.ts:215:8)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:341:7
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931587-0.3692116767036351'[39m,
  timestamp: [35m2025-12-26T01:02:11.587Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931587-0.6181930774296454'[39m,
  timestamp: [35m2025-12-26T01:02:11.587Z[39m,
  actualNote: { note: [32m'G'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was G. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mclears all timers on pause even if already cleared
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.598Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mmanual complete does not emit sessionComplete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mpause/resume preserves exact round state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931600-0.10944534104689296'[39m,
  timestamp: [35m2025-12-26T01:02:11.600Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931601-0.6115973469312475'[39m,
  timestamp: [35m2025-12-26T01:02:11.601Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/GuessActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mclears all timers on pause even if already cleared
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.613Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.pause (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:585:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:308:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mmanual complete does not emit sessionComplete
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses guesses even during intermission (state machine handles filtering)
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mclears all timers on pause even if already cleared
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mAuto-Advance After Timeout[2m > [22m[2mclears timer when paused during intermission
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931599-0.808663081840648'[39m,
  timestamp: [35m2025-12-26T01:02:11.599Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931599-0.8902938216555976'[39m,
  timestamp: [35m2025-12-26T01:02:11.599Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mmanual complete does not emit sessionComplete
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.574Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles timer cancellation during rapid state changes
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.605Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/GuessActions.test.ts[2m > [22m[2mGuess Actions: Events[2m > [22m[2mGuess Processing Behavior[2m > [22m[2mprocesses all guess submissions (no client-side deduplication)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.590Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mMultiple Timer Cancellations[2m > [22m[2mhandles timer cancellation during rapid state changes
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.615Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.608Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.605Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931608-0.25201584382119147'[39m,
  timestamp: [35m2025-12-26T01:02:11.608Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931609-0.8455988337366831'[39m,
  timestamp: [35m2025-12-26T01:02:11.609Z[39m,
  actualNote: { note: [32m'A'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was A. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mstats remain accessible after completion
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.591Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.607Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2memits stateChange to completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/StateChangeActions.test.ts:375:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

 [31mâ¯[39m src/game/events/GuessActions.test.ts [2m([22m[2m20 tests[22m[2m | [22m[31m18 failed[39m[2m)[22m[32m 83[2mms[22m[39m
[31m       [31mÃ—[31m emits guessAttempt event with correct payload for correct guess[39m[32m 23[2mms[22m[39m
[31m       [31mÃ—[31m emits guessResult event with isCorrect: true[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m updates stats correctly on correct guess[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m transitions from waiting_input â†’ processing_guess â†’ timeout_intermission[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m increments currentStreak on correct guess[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m emits guessAttempt event with isCorrect: false[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m emits guessResult event with incorrect feedback[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m resets current streak to 0 on incorrect guess[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m increments totalAttempts but not correctCount[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m stays in waiting_input (sandbox allows retry)[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m emits guessAttempt with guessedNote: null on timeout[39m[32m 5[2mms[22m[39m
[31m       [31mÃ—[31m reveals correct note in feedback message[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m resets streak to 0 on timeout[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m schedules auto-advance to next round[32m 7[2mms[22m[39m
       [32mâœ“[39m increments totalAttempts on timeout[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m emits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m does not emit sessionComplete for normal guesses[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m emits sessionComplete when guess completes game[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m processes guesses even during intermission (state machine handles filtering)[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m processes all guess submissions (no client-side deduplication)[39m[32m 2[2mms[22m[39m
[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.617Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mtransitions from timeout_intermission to waiting_input
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2memits stateChange to completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mComplex State Sequences[2m > [22m[2mcompletion from different round states emits correct stateChange
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931607-0.45638063665726425'[39m,
  timestamp: [35m2025-12-26T01:02:11.607Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931607-0.43440419978142986'[39m,
  timestamp: [35m2025-12-26T01:02:11.607Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.608Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m2[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [33m80[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [33m10[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m2[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles complete game lifecycle without errors
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2memits stateChange to completed state
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.594Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.619Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mdoes not emit roundStart without calling startNewRound
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.612Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.597Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.610Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:46:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.614Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.complete (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:601:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:314:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mrapid pause/resume cycles emit all state changes
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mState Transition Sequences[2m > [22m[2mhandles invalid transition attempts gracefully
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931615-0.5036880932843701'[39m,
  timestamp: [35m2025-12-26T01:02:11.615Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931619-0.941084332283803'[39m,
  timestamp: [35m2025-12-26T01:02:11.619Z[39m,
  actualNote: { note: [32m'B'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was B. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m1000[39m ms
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mclears all active timers on complete
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931597-0.5843962383592183'[39m,
  timestamp: [35m2025-12-26T01:02:11.597Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931598-0.1336957056847885'[39m,
  timestamp: [35m2025-12-26T01:02:11.598Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.599Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m2[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m2[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mpausing from idle still emits stateChange
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.620Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mpausing from idle still emits stateChange
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [1mnull[22m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: idle
[Orchestrator] Emitting event: stateChange { sessionState: [32m'idle'[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mguessAttempt always includes all required fields
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.621Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/RoundFlowActions.test.ts:43:19
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mstate changes include both session and round context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mManual Round Advancement[2m > [22m[2mallows starting new round after manual advance
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mComplete Game[2m > [22m[2mcalculates accuracy correctly via getStats
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.601Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mState Transition Edge Cases[2m > [22m[2mstate changes include both session and round context
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.623Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2memits stateChange when transitioning between round states
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.622Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mstateChange always includes sessionState
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.623Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.603Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mround states only exist within playing session state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.620Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound State Transitions[2m > [22m[2mmaintains sessionState as playing during round transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.624Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2memits feedbackUpdate with initial message on reset
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mstays in playing.waiting_input state after reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mEvent Payload Consistency[2m > [22m[2mroundStart always includes note and feedback
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.629Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'C'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.626Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mstays in playing.waiting_input state after reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.622Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.626Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mstays in playing.waiting_input state after reset
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mpaused state has no round state
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.636Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mhandles rapid round start calls
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.626Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstderr[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/events/EdgeCaseActions.test.ts:556:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mcan start round even when completed (no state guards)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mstop() clears all timers and subscriptions
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931636-0.020131768401114192'[39m,
  timestamp: [35m2025-12-26T01:02:11.636Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931636-0.9437473361063531'[39m,
  timestamp: [35m2025-12-26T01:02:11.636Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mcan start round even when completed (no state guards)
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.628Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.606Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.624Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mcan start round even when completed (no state guards)
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.629Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstderr[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.resetGame (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:620:10)
    at C:/Users/gavin/repos/meta/src/game/events/SessionActions.test.ts:388:20
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:753:20

[90mstdout[2m | src/game/events/StateChangeActions.test.ts[2m > [22m[2mState Change Actions: Events[2m > [22m[2mSession vs Round State Correlation[2m > [22m[2mcompleted state has no round state
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.624Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/EdgeCaseActions.test.ts[2m > [22m[2mEdge Case Actions: Events[2m > [22m[2mResource Cleanup[2m > [22m[2mclears timers before state transitions
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.638Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears all timers on reset
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931606-0.06170849911019416'[39m,
  timestamp: [35m2025-12-26T01:02:11.606Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710931606-0.162364897255997'[39m,
  timestamp: [35m2025-12-26T01:02:11.606Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Clearing timer: advance-after-timeout
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] Clearing all timers. Active timers: [ [32m'advance-after-timeout'[39m ]
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed to: playing -> timeout_intermission
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Edge Cases[2m > [22m[2mpreserves round count across multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.631Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan start new round after advancing from intermission
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.633Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [31mâ¯[39m src/game/events/StateChangeActions.test.ts [2m([22m[2m22 tests[22m[2m | [22m[31m7 failed[39m[2m)[22m[32m 119[2mms[22m[39m
       [32mâœ“[39m IDLE â†’ PLAYING: startGame()[32m 14[2mms[22m[39m
       [32mâœ“[39m PLAYING â†’ PAUSED: pause()[32m 7[2mms[22m[39m
       [32mâœ“[39m PAUSED â†’ PLAYING: resume()[32m 8[2mms[22m[39m
       [32mâœ“[39m PLAYING â†’ COMPLETED: complete()[32m 3[2mms[22m[39m
       [32mâœ“[39m COMPLETED â†’ IDLE: reset()[32m 3[2mms[22m[39m
       [32mâœ“[39m COMPLETED â†’ PLAYING: playAgain()[32m 15[2mms[22m[39m
[31m       [31mÃ—[31m WAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m PROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m WAITING_INPUT â†’ TIMEOUT_INTERMISSION: handleTimeout()[32m 8[2mms[22m[39m
       [32mâœ“[39m TIMEOUT_INTERMISSION â†’ WAITING_INPUT: ADVANCE_ROUND[32m 3[2mms[22m[39m
       [32mâœ“[39m includes sessionState in all transitions[32m 15[2mms[22m[39m
[31m       [31mÃ—[31m includes roundState for round transitions[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m session state remains "playing" during round transitions[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m emits all state changes in correct order for full game flow[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m pause/resume preserves exact round state[32m 6[2mms[22m[39m
       [32mâœ“[39m completion from different round states emits correct stateChange[32m 5[2mms[22m[39m
[31m       [31mÃ—[31m rapid pause/resume cycles emit all state changes[39m[32m 7[2mms[22m[39m
       [32mâœ“[39m pausing from idle still emits stateChange[32m 1[2mms[22m[39m
       [32mâœ“[39m state changes include both session and round context[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m round states only exist within playing session state[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m paused state has no round state[32m 2[2mms[22m[39m
       [32mâœ“[39m completed state has no round state[32m 2[2mms[22m[39m
 [31mâ¯[39m src/game/events/EdgeCaseActions.test.ts [2m([22m[2m26 tests[22m[2m | [22m[31m16 failed[39m[2m)[22m[32m 117[2mms[22m[39m
[31m       [31mÃ—[31m processes all rapid guess submissions[39m[32m 23[2mms[22m[39m
[31m       [31mÃ—[31m subsequent guesses processed but state machine may ignore[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m only first guess counts in stats (subsequent ignored by state machine)[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m handles rapid pause/resume cycles[32m 6[2mms[22m[39m
[31m       [31mÃ—[31m emits stateChange for each pause/resume[39m[32m 11[2mms[22m[39m
[31m       [31mÃ—[31m preserves state through rapid cycles[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m preserves intermission state when paused[32m 4[2mms[22m[39m
       [32mâœ“[39m clears auto-advance timer when pausing during intermission[32m 7[2mms[22m[39m
       [32mâœ“[39m can pause and resume multiple times during intermission[32m 10[2mms[22m[39m
[31m       [31mÃ—[31m emits events in correct order for guess flow[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m stateChange always precedes dependent events[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m no duplicate event emissions for single action[39m[32m 1[2mms[22m[39m
[31m       [31mÃ—[31m processes guess even when in timeout_intermission[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m processes guess even when paused[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m processes guess even when completed[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m warns when no current note (idle state)[32m 2[2mms[22m[39m
       [32mâœ“[39m handles multiple pause calls without errors[32m 3[2mms[22m[39m
       [32mâœ“[39m clears all timers on pause even if already cleared[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m handles timer cancellation during rapid state changes[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m handles complete game lifecycle without errors[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m handles invalid transition attempts gracefully[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m guessAttempt always includes all required fields[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m stateChange always includes sessionState[32m 5[2mms[22m[39m
[31m       [31mÃ—[31m roundStart always includes note and feedback[39m[32m 8[2mms[22m[39m
       [32mâœ“[39m stop() clears all timers and subscriptions[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m clears timers before state transitions[39m[32m 2[2mms[22m[39m
[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mclears current note on reset
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.611Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/RoundFlowActions.test.ts[2m > [22m[2mRound Flow Actions: Events[2m > [22m[2mRound Flow Lifecycle[2m > [22m[2mcan cycle through multiple rounds
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.635Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from playing state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from playing state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from playing state
[22m[39m[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mReset Game[2m > [22m[2mcan reset from completed state
[22m[39m[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:11.616Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}
[Orchestrator] State changed: completed
[Orchestrator] Emitting event: stateChange { sessionState: [32m'completed'[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: idle
[Orchestrator] Emitting event: stateChange { sessionState: [32m'idle'[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session

 [31mâ¯[39m src/game/events/RoundFlowActions.test.ts [2m([22m[2m27 tests[22m[2m | [22m[31m13 failed[39m[2m)[22m[32m 126[2mms[22m[39m
[31m       [31mÃ—[31m emits roundStart with generated note and feedback[39m[32m 29[2mms[22m[39m
[31m       [31mÃ—[31m generates note using configured note filter[39m[32m 3[2mms[22m[39m
       [32mâœ“[39m transitions to waiting_input state[32m 2[2mms[22m[39m
       [32mâœ“[39m calls game mode onStartNewRound callback[32m 2[2mms[22m[39m
       [32mâœ“[39m can start from idle state (first round)[32m 3[2mms[22m[39m
       [32mâœ“[39m can start from timeout_intermission state[32m 7[2mms[22m[39m
       [32mâœ“[39m feedback message is mode-specific[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m roundStart includes context with note for ear training[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m schedules auto-advance timer after correct guess[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m can manually advance after correct guess[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m clears previous auto-advance timer if called again[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m auto-advance can be cancelled by pause[39m[32m 5[2mms[22m[39m
       [32mâœ“[39m schedules auto-advance timer after timeout[32m 3[2mms[22m[39m
       [32mâœ“[39m delay is capped at 2 seconds for timeout auto-advance[32m 4[2mms[22m[39m
       [32mâœ“[39m sends ADVANCE_ROUND action after delay[32m 5[2mms[22m[39m
       [32mâœ“[39m can manually advance after timeout[32m 3[2mms[22m[39m
       [32mâœ“[39m clears timer when paused during intermission[32m 11[2mms[22m[39m
       [32mâœ“[39m transitions from timeout_intermission to waiting_input[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m does not emit roundStart without calling startNewRound[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m allows starting new round after manual advance[32m 8[2mms[22m[39m
[31m       [31mÃ—[31m emits stateChange when transitioning between round states[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m maintains sessionState as playing during round transitions[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m handles rapid round start calls[32m 2[2mms[22m[39m
       [32mâœ“[39m can start round even when completed (no state guards)[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m preserves round count across multiple rounds[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m can start new round after advancing from intermission[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m can cycle through multiple rounds[39m[32m 2[2mms[22m[39m
[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2memits stateChange to playing.waiting_input
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.618Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mresets orchestrator stats to 0
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.621Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mpreserves game mode settings
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.622Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'E'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mclears all timers before transitioning
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.624Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mPlay Again[2m > [22m[2mcan only be called from completed state
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.626Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.628Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[22m[39m[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] State changed: paused
[Orchestrator] Emitting event: stateChange { sessionState: [32m'paused'[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/events/SessionActions.test.ts[2m > [22m[2mSession Actions: Events[2m > [22m[2mSession Lifecycle Flow[2m > [22m[2mpreserves stats through pause/resume but resets on play again
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.631Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}

 [31mâ¯[39m src/game/events/SessionActions.test.ts [2m([22m[2m32 tests[22m[2m | [22m[31m14 failed[39m[2m)[22m[32m 123[2mms[22m[39m
       [32mâœ“[39m emits stateChange event when transitioning from idle to playing[32m 14[2mms[22m[39m
       [32mâœ“[39m transitions to playing.waiting_input state[32m 4[2mms[22m[39m
       [32mâœ“[39m clears all active timers before starting[32m 4[2mms[22m[39m
       [32mâœ“[39m can be called from idle state[32m 2[2mms[22m[39m
       [32mâœ“[39m emits stateChange to paused when pause() called[32m 2[2mms[22m[39m
       [32mâœ“[39m clears all active timers on pause[32m 9[2mms[22m[39m
       [32mâœ“[39m can pause from waiting_input state[32m 2[2mms[22m[39m
       [32mâœ“[39m can pause from timeout_intermission state[32m 3[2mms[22m[39m
       [32mâœ“[39m emits stateChange returning to previous round state[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m preserves stats across pause/resume[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m preserves current note across pause/resume[39m[32m 4[2mms[22m[39m
       [32mâœ“[39m returns to waiting_input after resume from waiting_input pause[32m 3[2mms[22m[39m
       [32mâœ“[39m returns to timeout_intermission after resume from intermission pause[32m 5[2mms[22m[39m
[31m       [31mÃ—[31m transitions to completed state[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m manual complete does not emit sessionComplete[39m[32m 4[2mms[22m[39m
[31m       [31mÃ—[31m stats remain accessible after completion[39m[32m 4[2mms[22m[39m
       [32mâœ“[39m emits stateChange to completed state[32m 2[2mms[22m[39m
       [32mâœ“[39m clears all active timers on complete[32m 5[2mms[22m[39m
[31m       [31mÃ—[31m calculates accuracy correctly via getStats[39m[32m 2[2mms[22m[39m
       [32mâœ“[39m emits feedbackUpdate with initial message on reset[32m 2[2mms[22m[39m
       [32mâœ“[39m stays in playing.waiting_input state after reset[32m 2[2mms[22m[39m
       [32mâœ“[39m clears all timers on reset[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m clears current note on reset[39m[32m 4[2mms[22m[39m
       [32mâœ“[39m can reset from playing state[32m 2[2mms[22m[39m
       [32mâœ“[39m can reset from completed state[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m emits stateChange to playing.waiting_input[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m resets orchestrator stats to 0[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m preserves game mode settings[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m clears all timers before transitioning[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m can only be called from completed state[39m[32m 2[2mms[22m[39m
[31m       [31mÃ—[31m completes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again[39m[32m 3[2mms[22m[39m
[31m       [31mÃ—[31m preserves stats through pause/resume but resets on play again[39m[32m 2[2mms[22m[39m
[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould count down session timer over time
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould count down session timer over time
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.712Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould initialize timer to responseTimeLimit value
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould initialize timer to responseTimeLimit value
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.806Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mtimer continues until completion
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould call onTimeUpdate callback during countdown
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould call onTimeUpdate callback during countdown
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:11.977Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTimer Behavior[2m > [22m[2mhandles per-note timeouts
[22m[39m[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during processing_guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during timeout_intermission
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: timeout { type: [32m'timeout'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves all stats across multiple pauses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTarget Variations[2m > [22m[2mcompletes with minimal target (3 notes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTarget Variations[2m > [22m[2mcompletes with medium target (5 notes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mTarget Variations[2m > [22m[2mcompletes with larger target and errors (10 notes)
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mcompletes after many incorrect attempts
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: incorrect_guess { type: [32m'incorrect_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mhandles rapid pause/resume cycles
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/RushMode.test.ts[2m > [22m[2mRush Mode Integration Tests[2m > [22m[2mEdge Cases[2m > [22m[2mresets stats on play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'F4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/RushMode.test.ts [2m([22m[2m17 tests[22m[2m)[22m[33m 612[2mms[22m[39m
       [33m[2mâœ“[22m[39m timer continues until completion [33m 331[2mms[22m[39m
[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mgame completes automatically when timer reaches 0
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould show correct time after specific duration
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould show correct time after specific duration
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:12.439Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'D'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould pause timer when game is paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould pause timer when game is paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:12.505Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'G'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould pause timer when game is paused
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mSession Timer[2m > [22m[2mgame completes automatically when timer reaches 0
[22m[39m[gameStateMachine] TIMEOUT event received - transitioning to COMPLETED
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state (applySettings) - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:12.854Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    totalAttempts: [33m0[39m,
    settings: {
      sessionDuration: [33m0.008333333333333333[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [90mundefined[39m
    },
    results: { notesCompleted: [33m0[39m, longestStreak: [33m0[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m0[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m0[39m,
    totalAttempts: [33m0[39m,
    correctAttempts: [33m0[39m
  }
}

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves state when paused during waiting_input
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPause/Resume[2m > [22m[2mpreserves stats across multiple pauses
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPlay Again[2m > [22m[2mresets stats on play again
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'D4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'E4'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[GameOrchestrator] Detected COMPLETED state - calling handleExternalCompletion
[GameOrchestrator] handleExternalCompletion called - gameMode.isCompleted: [33mfalse[39m
[GameOrchestrator] Getting final stats from game mode
[Orchestrator] Emitting event: sessionComplete {
  session: {
    mode: [32m'sandbox'[39m,
    timestamp: [35m2025-12-26T01:02:13.036Z[39m,
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    totalAttempts: [33m3[39m,
    settings: {
      sessionDuration: [33m5[39m,
      targetAccuracy: [90mundefined[39m,
      targetStreak: [90mundefined[39m,
      targetNotes: [33m3[39m
    },
    results: { notesCompleted: [33m3[39m, longestStreak: [33m3[39m, averageTimePerNote: [33m0[39m }
  },
  stats: {
    completionTime: [33m0[39m,
    accuracy: [33m100[39m,
    averageTimePerNote: [33m0[39m,
    longestStreak: [33m3[39m,
    totalAttempts: [33m3[39m,
    correctAttempts: [33m3[39m
  }
}
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstderr[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPlay Again[2m > [22m[2mresets stats on play again
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/SandboxMode.test.ts:19:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/SandboxMode.test.ts[2m > [22m[2mSandbox Mode Integration Tests[2m > [22m[2mPlay Again[2m > [22m[2mresets stats on play again
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

 [32mâœ“[39m src/game/SandboxMode.test.ts [2m([22m[2m14 tests[22m[2m)[22m[33m 1556[2mms[22m[39m
       [33m[2mâœ“[22m[39m timer configuration is passed correctly for countdown mode [33m 668[2mms[22m[39m
       [33m[2mâœ“[22m[39m game completes automatically when timer reaches 0 [33m 820[2mms[22m[39m
[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould pause session timer when game is paused
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould pause session timer when game is paused
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:13.161Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:13.244Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'B'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/machines/services/timerService.test.ts [2m([22m[2m8 tests[22m[2m)[22m[32m 38[2mms[22m[39m
 [32mâœ“[39m src/machines/roundTimer.test.ts [2m([22m[2m15 tests[22m[2m)[22m[32m 67[2mms[22m[39m
[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould pause session timer when game is paused
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mInitialization[2m > [22m[2mshould start in IDLE state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mInitialization[2m > [22m[2mshould initialize with empty context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from IDLE to PLAYING on START_GAME
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from IDLE to PLAYING on START_GAME
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to PAUSED on PAUSE
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to PAUSED on PAUSE
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PAUSED to PLAYING on RESUME
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PAUSED to PLAYING on RESUME
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to COMPLETED on COMPLETE
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from PLAYING to COMPLETED on COMPLETE
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to IDLE on RESET
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to IDLE on RESET
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] Sending event: reset { type: [32m'reset'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: idle
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'"idle"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: idle matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: complete { type: [32m'complete'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: completed
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"completed"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: completed matches: [36m[Function: matches][39m
[Orchestrator] User clicked Play Again
[Orchestrator] Sending event: play_again { type: [32m'play_again'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"completed"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameReset [90mundefined[39m
[Orchestrator] Emitting event: feedbackUpdate Click "Start Practice" to begin your ear training session
[Orchestrator] Scheduling timer: play-again-delay delay: [33m100[39m ms

[90mstderr[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39mTrace: [Orchestrator] clearAllTimers called from:
    at GameOrchestrator.clearAllTimers (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:351:15)
    at GameOrchestrator.stop (C:/Users/gavin/repos/meta/src/game/GameOrchestrator.ts:256:10)
    at C:/Users/gavin/repos/meta/src/game/GameOrchestrator.test.ts:14:18
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:157:11
    at file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1636:20
    at new Promise (<anonymous>)
    at runWithTimeout (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1602:10)
    at runHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1171:51)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1177:25)
    at callSuiteHook (file:///C:/Users/gavin/repos/meta/node_modules/@vitest/runner/dist/index.js:1184:27)

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSession State Transitions[2m > [22m[2mshould transition from COMPLETED to PLAYING on PLAY_AGAIN
[22m[39m[Orchestrator] Clearing all timers. Active timers: [ [32m'play-again-delay'[39m ]

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould start in WAITING_INPUT round state
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould start in WAITING_INPUT round state
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to PROCESSING_GUESS after MAKE_GUESS
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to PROCESSING_GUESS after MAKE_GUESS
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to PROCESSING_GUESS after MAKE_GUESS
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to TIMEOUT_INTERMISSION after CORRECT_GUESS
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to TIMEOUT_INTERMISSION after CORRECT_GUESS
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition to TIMEOUT_INTERMISSION after CORRECT_GUESS
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition back to WAITING_INPUT after ADVANCE_ROUND
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition back to WAITING_INPUT after ADVANCE_ROUND
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mRound State Queries[2m > [22m[2mshould transition back to WAITING_INPUT after ADVANCE_ROUND
[22m[39m[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: advance_round { type: [32m'advance_round'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'{"playing":"timeout_intermission"}'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get current note from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get user guess from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get stats from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould get feedback message from context
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould update stats after correct guess
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mContext Accessors[2m > [22m[2mshould update stats after correct guess
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: make_guess { type: [32m'make_guess'[39m, guessedNote: [32m'C'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'processing_guess'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'processing_guess'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"processing_guess"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'processing_guess'[39m }
[Orchestrator] After send, state is: { playing: [32m'processing_guess'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: correct_guess { type: [32m'correct_guess'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'timeout_intermission'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"processing_guess"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }
[Orchestrator] After send, state is: { playing: [32m'timeout_intermission'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould notify subscribers on state changes
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould notify subscribers on state changes
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould unsubscribe correctly
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mSubscription[2m > [22m[2mshould unsubscribe correctly
[22m[39m[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed to: playing -> waiting_input
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: paused
[Orchestrator] State changed: {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mCleanup[2m > [22m[2mshould clean up all subscriptions on stop
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/GameOrchestrator.test.ts[2m > [22m[2mGameOrchestrator[2m > [22m[2mCleanup[2m > [22m[2mshould clean up all subscriptions on stop
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] State changed: {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] âš¡ Subscription callback fired, snapshot.value: { playing: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/game/GameOrchestrator.test.ts [2m([22m[2m20 tests[22m[2m)[22m[32m 71[2mms[22m[39m
 [32mâœ“[39m src/game/SingleChordGameState.test.ts [2m([22m[2m14 tests[22m[2m)[22m[32m 11[2mms[22m[39m
 [32mâœ“[39m src/game/strategies/EarTrainingStrategy.test.ts [2m([22m[2m30 tests[22m[2m)[22m[32m 22[2mms[22m[39m
[90mstdout[2m | src/machines/gameStateMachine.test.ts[2m > [22m[2mGame State Machine[2m > [22m[2mTimer Behavior[2m > [22m[2mshould transition to COMPLETED when TIMEOUT event is received
[22m[39m[gameStateMachine] TIMEOUT event received - transitioning to COMPLETED

[90mstdout[2m | src/machines/gameStateMachine.test.ts[2m > [22m[2mGame State Machine[2m > [22m[2mTimer Behavior[2m > [22m[2mshould transition to COMPLETED from any round state on TIMEOUT
[22m[39m[gameStateMachine] TIMEOUT event received - transitioning to COMPLETED

 [32mâœ“[39m src/game/ChordIdentificationGameState.test.ts [2m([22m[2m14 tests[22m[2m)[22m[32m 11[2mms[22m[39m
 [32mâœ“[39m src/machines/gameStateMachine.test.ts [2m([22m[2m27 tests[22m[2m)[22m[32m 26[2mms[22m[39m
[90mstderr[2m | src/game/GameStateFactory.test.tsx[2m > [22m[2mGameStateFactory[2m > [22m[2mFallback Behavior[2m > [22m[2mshould fallback to sandbox for unknown mode
[22m[39mUnknown mode: unknown-mode, falling back to sandbox

 [32mâœ“[39m src/game/GameStateInterfaceCompliance.test.tsx [2m([22m[2m64 tests[22m[2m)[22m[32m 14[2mms[22m[39m
 [32mâœ“[39m src/game/GameStateFactory.test.tsx [2m([22m[2m18 tests[22m[2m)[22m[32m 14[2mms[22m[39m
 [32mâœ“[39m src/utils/chordValidation.test.ts [2m([22m[2m46 tests[22m[2m)[22m[32m 18[2mms[22m[39m
 [32mâœ“[39m src/game/strategies/ChordTrainingStrategy.test.ts [2m([22m[2m41 tests[22m[2m)[22m[32m 22[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould resume timer when game is resumed
[22m[39m[Orchestrator] User pressed unpause
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameResumed [90mundefined[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:13.883Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'F'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

 [32mâœ“[39m src/utils/chordInversions.test.ts [2m([22m[2m21 tests[22m[2m)[22m[32m 8[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] start() called, creating actor subscription
[Orchestrator] Actor status before start: active
[Orchestrator] Actor status after start: active
[Orchestrator] Initial state: idle
[Orchestrator] Setting up subscription...
[Orchestrator] About to call this.actor.subscribe(), actor status: active
[Orchestrator] Subscription object created: object { unsubscribe: [36m[Function: unsubscribe][39m }
[Orchestrator] Adding subscription to subscriptions array
[Orchestrator] Subscriptions count: [33m1[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] Emitting event: roundStart {
  context: {
    startTime: [35m2025-12-26T01:02:14.172Z[39m,
    elapsedTime: [33m0[39m,
    note: { note: [32m'A'[39m, octave: [33m4[39m },
    noteHighlights: [],
    guessedNote: [90mundefined[39m
  },
  feedback: [32m'Listen to the note and identify it on the keyboard (0/5)'[39m
}
[Orchestrator] Sending event: start_game { type: [32m'start_game'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [1mnull[22m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] User pressed pause
[Orchestrator] Sending event: pause { type: [32m'pause'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'0'[39m,
  roundState: [90mundefined[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'"paused"'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'0'[39m, roundState: [90mundefined[39m }
[Orchestrator] After send, state is: paused matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gamePaused [90mundefined[39m

 [32mâœ“[39m src/game/ChordIdentificationTimerMethods.test.ts [2m([22m[2m14 tests[22m[2m)[22m[32m 6[2mms[22m[39m
[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] User pressed unpause
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameResumed [90mundefined[39m

 [32mâœ“[39m src/components/NoteIdentification.test.tsx [2m([22m[2m8 tests[22m[2m)[22m[32m 5[2mms[22m[39m
[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] User pressed unpause
[Orchestrator] Sending event: resume { type: [32m'resume'[39m }
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'waiting_input'[39m,
  previousState: [32m'"paused"'[39m,
  currentState: [32m'{"playing":"waiting_input"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'waiting_input'[39m }
[Orchestrator] After send, state is: { playing: [32m'waiting_input'[39m } matches: [36m[Function: matches][39m
[Orchestrator] Emitting event: gameResumed [90mundefined[39m

[90mstdout[2m | src/game/TimerBehavior.test.ts[2m > [22m[2mTimer Behavior[2m > [22m[2mshould preserve timer value across pause/resume cycle
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710934759-0.4915468108847165'[39m,
  timestamp: [35m2025-12-26T01:02:14.759Z[39m,
  actualNote: { note: [32m'E'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was E. Try again!"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

[90mstdout[2m | src/game/SessionTimerBehavior.test.ts[2m > [22m[2mSession Timer Behavior (Sandbox Mode)[2m > [22m[2mshould resume session timer when game is resumed
[22m[39m[Orchestrator] Emitting event: guessAttempt {
  id: [32m'1766710934759-0.951206160825792'[39m,
  timestamp: [35m2025-12-26T01:02:14.759Z[39m,
  actualNote: { note: [32m'F'[39m, octave: [33m4[39m },
  guessedNote: [1mnull[22m,
  isCorrect: [33mfalse[39m
}
[Orchestrator] Emitting event: guessResult {
  isCorrect: [33mfalse[39m,
  feedback: [32m"Time's up! The correct answer was F. Incorrect. Accuracy: 0.0% | Streak reset"[39m,
  shouldAdvance: [33mfalse[39m,
  gameCompleted: [33mfalse[39m,
  stats: [90mundefined[39m
}
[Orchestrator] Scheduling timer: advance-after-timeout delay: [33m2000[39m ms
[Orchestrator] State changed (applySettings subscription): {
  sessionState: [32m'playing'[39m,
  roundState: [32m'timeout_intermission'[39m,
  previousState: [32m'{"playing":"waiting_input"}'[39m,
  currentState: [32m'{"playing":"timeout_intermission"}'[39m
}
[Orchestrator] Emitting event: stateChange { sessionState: [32m'playing'[39m, roundState: [32m'timeout_intermission'[39m }

 [32mâœ“[39m src/game/SessionTimerBehavior.test.ts [2m([22m[2m5 tests[22m[2m)[22m[33m 3320[2mms[22m[39m
     [33m[2mâœ“[22m[39m should count down session timer over time [33m 727[2mms[22m[39m
     [33m[2mâœ“[22m[39m should show correct time after specific duration [33m 723[2mms[22m[39m
     [33m[2mâœ“[22m[39m should pause session timer when game is paused [33m 723[2mms[22m[39m
     [33m[2mâœ“[22m[39m should resume session timer when game is resumed [33m 923[2mms[22m[39m
 [32mâœ“[39m src/game/TimerBehavior.test.ts [2m([22m[2m6 tests[22m[2m)[22m[33m 3463[2mms[22m[39m
     [33m[2mâœ“[22m[39m should start timer countdown when round begins [33m 320[2mms[22m[39m
     [33m[2mâœ“[22m[39m should call onTimeUpdate callback during countdown [33m 529[2mms[22m[39m
     [33m[2mâœ“[22m[39m should pause timer when game is paused [33m 739[2mms[22m[39m
     [33m[2mâœ“[22m[39m should resume timer when game is resumed [33m 929[2mms[22m[39m
     [33m[2mâœ“[22m[39m should preserve timer value across pause/resume cycle [33m 774[2mms[22m[39m

[31mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[39m[1m[41m Failed Tests 79 [49m[22m[31mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[39m

[41m[1m FAIL [22m[49m src/components/PianoKeyboard.test.tsx[2m > [22mPianoKeyboard - Mono Mode[2m > [22mshould release all notes before playing new note when monoMode is true
[41m[1m FAIL [22m[49m src/components/PianoKeyboard.test.tsx[2m > [22mPianoKeyboard - Mono Mode[2m > [22mshould NOT release notes before playing when monoMode is false
[41m[1m FAIL [22m[49m src/components/PianoKeyboard.test.tsx[2m > [22mPianoKeyboard - Mono Mode[2m > [22mshould highlight notes with error type in red
[41m[1m FAIL [22m[49m src/components/PianoKeyboard.test.tsx[2m > [22mPianoKeyboard - Mono Mode[2m > [22mshould have preventNoteRestart prop available
[31m[1mError[22m: useSettings must be used within a SettingsProvider[39m
[36m [2mâ¯[22m useSettings src/hooks/useSettings.ts:[2m8:11[22m[39m
    [90m  6| [39m  [35mconst[39m context [33m=[39m [34museContext[39m([33mSettingsContext[39m)[33m;[39m
    [90m  7| [39m  [35mif[39m (context [33m===[39m undefined) {
    [90m  8| [39m    throw new Error('useSettings must be used within a SettingsProvideâ€¦
    [90m   | [39m          [31m^[39m
    [90m  9| [39m  }
    [90m 10| [39m  [35mreturn[39m context[33m;[39m
[90m [2mâ¯[22m PianoKeyboard src/components/PianoKeyboard.tsx:[2m66:24[22m[39m
[90m [2mâ¯[22m Object.react_stack_bottom_frame node_modules/react-dom/cjs/react-dom-client.development.js:[2m23863:20[22m[39m
[90m [2mâ¯[22m renderWithHooks node_modules/react-dom/cjs/react-dom-client.development.js:[2m5529:22[22m[39m
[90m [2mâ¯[22m updateFunctionComponent node_modules/react-dom/cjs/react-dom-client.development.js:[2m8897:19[22m[39m
[90m [2mâ¯[22m beginWork node_modules/react-dom/cjs/react-dom-client.development.js:[2m10522:18[22m[39m
[90m [2mâ¯[22m runWithFiberInDEV node_modules/react-dom/cjs/react-dom-client.development.js:[2m1522:13[22m[39m
[90m [2mâ¯[22m performUnitOfWork node_modules/react-dom/cjs/react-dom-client.development.js:[2m15140:22[22m[39m
[90m [2mâ¯[22m workLoopSync node_modules/react-dom/cjs/react-dom-client.development.js:[2m14956:41[22m[39m
[90m [2mâ¯[22m renderRootSync node_modules/react-dom/cjs/react-dom-client.development.js:[2m14936:11[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[1/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/ModeRegistry.test.ts[2m > [22mMode Registration Integration[2m > [22mshould have all expected modes registered
[31m[1mAssertionError[22m: expected 5 to be 4 // Object.is equality[39m

[32m- Expected[39m
[31m+ Received[39m

[32m- 4[39m
[31m+ 5[39m

[36m [2mâ¯[22m src/game/ModeRegistry.test.ts:[2m137:29[22m[39m
    [90m135| [39m    [90m// Verify all modes are registered[39m
    [90m136| [39m    [35mconst[39m allModes [33m=[39m modeRegistry[33m.[39m[34mgetAll[39m()[33m;[39m
    [90m137| [39m    expect(allModes.length).toBe(4); // Rush, Survival, Sandbox, Singlâ€¦
    [90m   | [39m                            [31m^[39m
    [90m138| [39m
    [90m139| [39m    [90m// Verify ear training modes exist[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[2/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/ModeRegistry.test.ts[2m > [22mMode Registration Integration[2m > [22mshould filter modes by type correctly
[31m[1mAssertionError[22m: expected 2 to be 1 // Object.is equality[39m

[32m- Expected[39m
[31m+ Received[39m

[32m- 1[39m
[31m+ 2[39m

[36m [2mâ¯[22m src/game/ModeRegistry.test.ts:[2m155:38[22m[39m
    [90m153| [39m
    [90m154| [39m    const noteTrainingModes = modeRegistry.getAllByType(TRAINING_MODESâ€¦
    [90m155| [39m    [34mexpect[39m(noteTrainingModes[33m.[39mlength)[33m.[39m[34mtoBe[39m([34m1[39m)[33m;[39m [90m// Single Chord[39m
    [90m   | [39m                                     [31m^[39m
    [90m156| [39m  })[33m;[39m
    [90m157| [39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[3/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/AudioActions.test.ts[2m > [22mAudio Actions: Events[2m > [22mInitial Note Playback (via startNewRound)[2m > [22memits roundStart event with note
[31m[1mAssertionError[22m: expected undefined to be defined[39m
[36m [2mâ¯[22m src/game/events/AudioActions.test.ts:[2m144:31[22m[39m
    [90m142| [39m
    [90m143| [39m      const roundStart = getLastEventPayload<any>(eventSpies.roundStarâ€¦
    [90m144| [39m      [34mexpect[39m(roundStart[33m.[39mnote)[33m.[39m[34mtoBeDefined[39m()[33m;[39m
    [90m   | [39m                              [31m^[39m
    [90m145| [39m      [34mexpect[39m(roundStart[33m.[39mnote)[33m.[39m[34mtoMatchObject[39m({
    [90m146| [39m        note[33m:[39m expect[33m.[39m[34many[39m([33mString[39m)[33m,[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[4/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/AudioActions.test.ts[2m > [22mAudio Actions: Events[2m > [22mInitial Note Playback (via startNewRound)[2m > [22mplays audio for the generated note
[31m[1mAssertionError[22m: expected undefined to be defined[39m
[36m [2mâ¯[22m src/game/events/AudioActions.test.ts:[2m163:31[22m[39m
    [90m161| [39m      [90m// THEN: roundStart emitted with note[39m
    [90m162| [39m      const roundStart = getLastEventPayload<any>(eventSpies.roundStarâ€¦
    [90m163| [39m      [34mexpect[39m(roundStart[33m.[39mnote)[33m.[39m[34mtoBeDefined[39m()[33m;[39m
    [90m   | [39m                              [31m^[39m
    [90m164| [39m
    [90m165| [39m      [90m// Audio playback happens internally via audioEngine.playNote()[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[5/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/AudioActions.test.ts[2m > [22mAudio Actions: Events[2m > [22mInitial Note Playback (via startNewRound)[2m > [22mgenerates new note for each round
[31m[1mAssertionError[22m: expected undefined to be defined[39m
[36m [2mâ¯[22m src/game/events/AudioActions.test.ts:[2m185:21[22m[39m
    [90m183| [39m
    [90m184| [39m      // THEN: Notes are generated (may or may not be different due toâ€¦
    [90m185| [39m      [34mexpect[39m(note1)[33m.[39m[34mtoBeDefined[39m()[33m;[39m
    [90m   | [39m                    [31m^[39m
    [90m186| [39m      [34mexpect[39m(note2)[33m.[39m[34mtoBeDefined[39m()[33m;[39m
    [90m187| [39m      [34mexpect[39m(note3)[33m.[39m[34mtoBeDefined[39m()[33m;[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[6/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/AudioActions.test.ts[2m > [22mAudio Actions: Events[2m > [22mAudio vs Event Separation[2m > [22mreplayNote is pure audio, startNewRound emits events
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/AudioActions.test.ts:[2m280:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[7/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/AudioActions.test.ts[2m > [22mAudio Actions: Events[2m > [22mAudio vs Event Separation[2m > [22mreplay does not interfere with game state or flow
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/AudioActions.test.ts:[2m300:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[8/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mRapid Guess Submissions[2m > [22mprocesses all rapid guess submissions
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m59:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[9/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mRapid Guess Submissions[2m > [22msubsequent guesses processed but state machine may ignore
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m73:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[10/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mRapid Guess Submissions[2m > [22monly first guess counts in stats (subsequent ignored by state machine)
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m94:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[11/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mRapid Pause/Resume Cycles[2m > [22memits stateChange for each pause/resume
[31m[1mAssertionError[22m: expected 18 to be 6 // Object.is equality[39m

[32m- Expected[39m
[31m+ Received[39m

[32m- 6[39m
[31m+ 18[39m

[36m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m134:56[22m[39m
    [90m132| [39m
    [90m133| [39m      [90m// THEN: 6 stateChange events (3 pauses + 3 resumes)[39m
    [90m134| [39m      [34mexpect[39m(eventSpies[33m.[39mstateChange[33m.[39mmock[33m.[39mcalls[33m.[39mlength)[33m.[39m[34mtoBe[39m([34m6[39m)[33m;[39m
    [90m   | [39m                                                       [31m^[39m
    [90m135| [39m    })[33m;[39m
    [90m136| [39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[12/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mRapid Pause/Resume Cycles[2m > [22mpreserves state through rapid cycles
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m141:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[13/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mEvent Order Verification[2m > [22memits events in correct order for guess flow
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m232:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[14/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mEvent Order Verification[2m > [22mstateChange always precedes dependent events
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m261:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[15/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mEvent Order Verification[2m > [22mno duplicate event emissions for single action
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m281:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[16/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mGuess Processing Behavior[2m > [22mprocesses guess even when in timeout_intermission
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m303:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[17/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mGuess Processing Behavior[2m > [22mprocesses guess even when paused
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m321:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[18/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mGuess Processing Behavior[2m > [22mprocesses guess even when completed
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m338:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[19/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mMultiple Timer Cancellations[2m > [22mhandles timer cancellation during rapid state changes
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m400:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[20/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mState Transition Sequences[2m > [22mhandles complete game lifecycle without errors
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m425:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[21/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mEvent Payload Consistency[2m > [22mguessAttempt always includes all required fields
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m469:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[22/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mEvent Payload Consistency[2m > [22mroundStart always includes note and feedback
[31m[1mAssertionError[22m: expected { context: { â€¦(5) }, â€¦(1) } to match object { note: ObjectContaining{â€¦}, â€¦(2) }[39m

[32m- Expected[39m
[31m+ Received[39m

[33m@@ -7,10 +7,6 @@[39m
[2m      },[22m
[2m      "noteHighlights": Any<Array>,[22m
[2m      "startTime": Any<Date>,[22m
[2m    },[22m
[2m    "feedback": Any<String>,[22m
[32m-   "note": ObjectContaining {[39m
[32m-     "note": Any<String>,[39m
[32m-     "octave": Any<Number>,[39m
[32m-   },[39m
[2m  }[22m

[36m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m519:28[22m[39m
    [90m517| [39m
    [90m518| [39m        const roundStart = getLastEventPayload<any>(eventSpies.roundStâ€¦
    [90m519| [39m        [34mexpect[39m(roundStart)[33m.[39m[34mtoMatchObject[39m({
    [90m   | [39m                           [31m^[39m
    [90m520| [39m          note[33m:[39m expect[33m.[39m[34mobjectContaining[39m({
    [90m521| [39m            note[33m:[39m expect[33m.[39m[34many[39m([33mString[39m)[33m,[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[23/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/EdgeCaseActions.test.ts[2m > [22mEdge Case Actions: Events[2m > [22mResource Cleanup[2m > [22mclears timers before state transitions
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/EdgeCaseActions.test.ts:[2m567:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[24/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mCorrect Guess Events[2m > [22memits guessAttempt event with correct payload for correct guess
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m60:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[25/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mCorrect Guess Events[2m > [22memits guessResult event with isCorrect: true
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m82:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[26/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mCorrect Guess Events[2m > [22mupdates stats correctly on correct guess
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m103:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[27/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mCorrect Guess Events[2m > [22mtransitions from waiting_input â†’ processing_guess â†’ timeout_intermission
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m122:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[28/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mCorrect Guess Events[2m > [22mincrements currentStreak on correct guess
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m140:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[29/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mIncorrect Guess Events[2m > [22memits guessAttempt event with isCorrect: false
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m167:38[22m[39m
    [90m165| [39m      [35mawait[39m orchestrator[33m.[39m[34mstartNewRound[39m()[33m;[39m
    [90m166| [39m      [35mconst[39m currentNote [33m=[39m [34mgetNoteFromRoundStart[39m(eventSpies)[33m;[39m
    [90m167| [39m      const wrongNote = currentNote!.note === 'C' ? TEST_NOTES.D4 : TEâ€¦
    [90m   | [39m                                     [31m^[39m
    [90m168| [39m      [34mclearEventSpies[39m(eventSpies)[33m;[39m
    [90m169| [39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[30/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mIncorrect Guess Events[2m > [22memits guessResult event with incorrect feedback
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m188:38[22m[39m
    [90m186| [39m      [35mawait[39m orchestrator[33m.[39m[34mstartNewRound[39m()[33m;[39m
    [90m187| [39m      [35mconst[39m currentNote [33m=[39m [34mgetNoteFromRoundStart[39m(eventSpies)[33m;[39m
    [90m188| [39m      const wrongNote = currentNote!.note === 'C' ? TEST_NOTES.D4 : TEâ€¦
    [90m   | [39m                                     [31m^[39m
    [90m189| [39m      [34mclearEventSpies[39m(eventSpies)[33m;[39m
    [90m190| [39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[31/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mIncorrect Guess Events[2m > [22mresets current streak to 0 on incorrect guess
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m209:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[32/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mIncorrect Guess Events[2m > [22mincrements totalAttempts but not correctCount
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m236:38[22m[39m
    [90m234| [39m      [35mawait[39m orchestrator[33m.[39m[34mstartNewRound[39m()[33m;[39m
    [90m235| [39m      [35mconst[39m currentNote [33m=[39m [34mgetNoteFromRoundStart[39m(eventSpies)[33m;[39m
    [90m236| [39m      const wrongNote = currentNote!.note === 'C' ? TEST_NOTES.D4 : TEâ€¦
    [90m   | [39m                                     [31m^[39m
    [90m237| [39m
    [90m238| [39m      [35mconst[39m initialStats [33m=[39m orchestrator[33m.[39m[34mgetStats[39m()[33m;[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[33/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mIncorrect Guess Events[2m > [22mstays in waiting_input (sandbox allows retry)
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m253:38[22m[39m
    [90m251| [39m      [35mawait[39m orchestrator[33m.[39m[34mstartNewRound[39m()[33m;[39m
    [90m252| [39m      [35mconst[39m currentNote [33m=[39m [34mgetNoteFromRoundStart[39m(eventSpies)[33m;[39m
    [90m253| [39m      const wrongNote = currentNote!.note === 'C' ? TEST_NOTES.D4 : TEâ€¦
    [90m   | [39m                                     [31m^[39m
    [90m254| [39m
    [90m255| [39m      expect(orchestrator.getSnapshot().matches('playing.waiting_inputâ€¦

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[34/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mTimeout Events (No Guess)[2m > [22memits guessAttempt with guessedNote: null on timeout
[31m[1mAssertionError[22m: expected "vi.fn()" to be called 1 times, but got 2 times[39m
[36m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m276:39[22m[39m
    [90m274| [39m
    [90m275| [39m      [90m// THEN: guessAttempt event emitted with null guess[39m
    [90m276| [39m      [34mexpect[39m(eventSpies[33m.[39mguessAttempt)[33m.[39m[34mtoHaveBeenCalledTimes[39m([34m1[39m)[33m;[39m
    [90m   | [39m                                      [31m^[39m
    [90m277| [39m
    [90m278| [39m      const attempt = getLastEventPayload<any>(eventSpies.guessAttemptâ€¦

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[35/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mTimeout Events (No Guess)[2m > [22mreveals correct note in feedback message
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m297:54[22m[39m
    [90m295| [39m      [90m// THEN: Feedback reveals the correct note[39m
    [90m296| [39m      [35mconst[39m result [33m=[39m getLastEventPayload[33m<[39many[33m>[39m(eventSpies[33m.[39mguessResult)[33m;[39m
    [90m297| [39m      [34mexpect[39m(result[33m.[39mfeedback)[33m.[39m[34mtoContain[39m(currentNote[33m![39m[33m.[39mnote)[33m;[39m
    [90m   | [39m                                                     [31m^[39m
    [90m298| [39m      [34mexpect[39m(result[33m.[39mfeedback[33m.[39m[34mtoLowerCase[39m())[33m.[39m[34mtoContain[39m([32m"time"[39m)[33m;[39m
    [90m299| [39m    })[33m;[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[36/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mTimeout Events (No Guess)[2m > [22mresets streak to 0 on timeout
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m305:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[37/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mEvent Order and Timing[2m > [22memits events in correct order: guessAttempt â†’ stateChange â†’ stateChange â†’ guessResult
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m370:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[38/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mEvent Order and Timing[2m > [22mdoes not emit sessionComplete for normal guesses
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m388:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[39/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mEvent Order and Timing[2m > [22memits sessionComplete when guess completes game
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m409:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[40/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mGuess Processing Behavior[2m > [22mprocesses guesses even during intermission (state machine handles filtering)
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m428:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[41/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/GuessActions.test.ts[2m > [22mGuess Actions: Events[2m > [22mGuess Processing Behavior[2m > [22mprocesses all guess submissions (no client-side deduplication)
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/GuessActions.test.ts:[2m442:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[42/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound Start[2m > [22memits roundStart with generated note and feedback
[31m[1mAssertionError[22m: expected { context: { â€¦(5) }, â€¦(1) } to match object { note: ObjectContaining{â€¦}, â€¦(1) }
(6 matching properties omitted from actual)[39m

[32m- Expected[39m
[31m+ Received[39m

[2m  {[22m
[2m    "feedback": Any<String>,[22m
[32m-   "note": ObjectContaining {[39m
[32m-     "note": Any<String>,[39m
[32m-     "octave": Any<Number>,[39m
[32m-   },[39m
[2m  }[22m

[36m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m56:26[22m[39m
    [90m 54| [39m
    [90m 55| [39m      const roundStart = getLastEventPayload<any>(eventSpies.roundStarâ€¦
    [90m 56| [39m      [34mexpect[39m(roundStart)[33m.[39m[34mtoMatchObject[39m({
    [90m   | [39m                         [31m^[39m
    [90m 57| [39m        note[33m:[39m expect[33m.[39m[34mobjectContaining[39m({
    [90m 58| [39m          note[33m:[39m expect[33m.[39m[34many[39m([33mString[39m)[33m,[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[43/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound Start[2m > [22mgenerates note using configured note filter
[31m[1mTypeError[22m: Cannot read properties of undefined (reading 'octave')[39m
[36m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m74:30[22m[39m
    [90m 72| [39m      [90m// THEN: Generated note respects filter[39m
    [90m 73| [39m      const roundStart = getLastEventPayload<any>(eventSpies.roundStarâ€¦
    [90m 74| [39m      [34mexpect[39m(roundStart[33m.[39mnote[33m.[39moctave)[33m.[39m[34mtoBe[39m([34m4[39m)[33m;[39m
    [90m   | [39m                             [31m^[39m
    [90m 75| [39m      expect(['C', 'D', 'E', 'F', 'G', 'A', 'B']).toContain(roundStartâ€¦
    [90m 76| [39m    })[33m;[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[44/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound Start[2m > [22mroundStart includes context with note for ear training
[31m[1mAssertionError[22m: expected { note: 'E', octave: 4 } to deeply equal undefined[39m

[32m- Expected:[39m 
undefined

[31m+ Received:[39m 
{
  "note": "E",
  "octave": 4,
}

[36m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m161:39[22m[39m
    [90m159| [39m
    [90m160| [39m      // THEN: context.note matches the deprecated note field (backwarâ€¦
    [90m161| [39m      [34mexpect[39m(roundStart[33m.[39mcontext[33m.[39mnote)[33m.[39m[34mtoEqual[39m(roundStart[33m.[39mnote)[33m;[39m
    [90m   | [39m                                      [31m^[39m
    [90m162| [39m
    [90m163| [39m      // THEN: chord-specific fields are undefined for ear training moâ€¦

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[45/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mAuto-Advance After Correct Guess[2m > [22mschedules auto-advance timer after correct guess
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m187:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[46/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mAuto-Advance After Correct Guess[2m > [22mcan manually advance after correct guess
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m202:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[47/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mAuto-Advance After Correct Guess[2m > [22mclears previous auto-advance timer if called again
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m218:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[48/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mAuto-Advance After Correct Guess[2m > [22mauto-advance can be cancelled by pause
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m234:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[49/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mManual Round Advancement[2m > [22mdoes not emit roundStart without calling startNewRound
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m342:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[50/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound State Transitions[2m > [22memits stateChange when transitioning between round states
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m380:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[51/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound State Transitions[2m > [22mmaintains sessionState as playing during round transitions
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m395:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[52/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound Flow Edge Cases[2m > [22mpreserves round count across multiple rounds
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m439:22[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[53/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound Flow Lifecycle[2m > [22mcan start new round after advancing from intermission
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m454:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[54/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/RoundFlowActions.test.ts[2m > [22mRound Flow Actions: Events[2m > [22mRound Flow Lifecycle[2m > [22mcan cycle through multiple rounds
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/RoundFlowActions.test.ts:[2m473:22[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[55/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mResume Game[2m > [22mpreserves stats across pause/resume
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m194:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[56/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mResume Game[2m > [22mpreserves current note across pause/resume
[31m[1mAssertionError[22m: expected null not to be null[39m
[36m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m211:31[22m[39m
    [90m209| [39m    [34mit[39m([32m'preserves current note across pause/resume'[39m[33m,[39m [35masync[39m () [33m=>[39m {
    [90m210| [39m      [90m// GIVEN: Paused with current note[39m
    [90m211| [39m      [34mexpect[39m(currentNote)[33m.[39mnot[33m.[39m[34mtoBeNull[39m()[33m;[39m
    [90m   | [39m                              [31m^[39m
    [90m212| [39m
    [90m213| [39m      [90m// WHEN: Resume, pause, resume[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[57/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mComplete Game[2m > [22mtransitions to completed state
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m260:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[58/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mComplete Game[2m > [22mmanual complete does not emit sessionComplete
[31m[1mAssertionError[22m: expected "vi.fn()" to not be called at all, but actually been called 1 times[90m

Received: 

[1m  1st vi.fn() call:

[22m    Array [
      Object {
        "session": Object {
          "accuracy": 0,
          "completionTime": 0,
          "mode": "sandbox",
          "results": Object {
            "averageTimePerNote": 0,
            "longestStreak": 0,
            "notesCompleted": 0,
          },
          "settings": Object {
            "sessionDuration": 5,
            "targetAccuracy": undefined,
            "targetNotes": undefined,
            "targetStreak": undefined,
          },
          "timestamp": 2025-12-26T01:02:11.574Z,
          "totalAttempts": 0,
        },
        "stats": Object {
          "accuracy": 0,
          "averageTimePerNote": 0,
          "completionTime": 0,
          "correctAttempts": 0,
          "longestStreak": 0,
          "totalAttempts": 0,
        },
      },
    ]
[31m[90m

Number of calls: [1m1[22m
[31m[39m
[36m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m277:46[22m[39m
    [90m275| [39m
    [90m276| [39m      // THEN: No sessionComplete event (only emitted on natural complâ€¦
    [90m277| [39m      [34mexpect[39m(eventSpies[33m.[39msessionComplete)[33m.[39mnot[33m.[39m[34mtoHaveBeenCalled[39m()[33m;[39m
    [90m   | [39m                                             [31m^[39m
    [90m278| [39m    })[33m;[39m
    [90m279| [39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[59/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mComplete Game[2m > [22mstats remain accessible after completion
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m284:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[60/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mComplete Game[2m > [22mcalculates accuracy correctly via getStats
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m324:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[61/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mReset Game[2m > [22mclears current note on reset
[31m[1mAssertionError[22m: expected null not to be null[39m
[36m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m398:24[22m[39m
    [90m396| [39m      [35mawait[39m orchestrator[33m.[39m[34mstartNewRound[39m()[33m;[39m
    [90m397| [39m      [35mconst[39m note [33m=[39m [34mgetNoteFromRoundStart[39m(eventSpies)[33m;[39m
    [90m398| [39m      [34mexpect[39m(note)[33m.[39mnot[33m.[39m[34mtoBeNull[39m()[33m;[39m
    [90m   | [39m                       [31m^[39m
    [90m399| [39m
    [90m400| [39m      [90m// WHEN: Reset game[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[62/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mPlay Again[2m > [22memits stateChange to playing.waiting_input
[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mPlay Again[2m > [22mresets orchestrator stats to 0
[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mPlay Again[2m > [22mpreserves game mode settings
[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mPlay Again[2m > [22mclears all timers before transitioning
[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mPlay Again[2m > [22mcan only be called from completed state
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m440:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[63/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mSession Lifecycle Flow[2m > [22mcompletes full lifecycle: start â†’ pause â†’ resume â†’ complete â†’ play again
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m529:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[64/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/SessionActions.test.ts[2m > [22mSession Actions: Events[2m > [22mSession Lifecycle Flow[2m > [22mpreserves stats through pause/resume but resets on play again
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/SessionActions.test.ts:[2m547:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[65/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mRound State Transitions[2m > [22mWAITING_INPUT â†’ PROCESSING_GUESS: submitGuess()
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m176:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[66/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mRound State Transitions[2m > [22mPROCESSING_GUESS â†’ TIMEOUT_INTERMISSION: after guess processed
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m192:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[67/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mstateChange Event Payloads[2m > [22mincludes roundState for round transitions
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m263:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[68/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mstateChange Event Payloads[2m > [22msession state remains "playing" during round transitions
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m282:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[69/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mComplex State Sequences[2m > [22memits all state changes in correct order for full game flow
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m309:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[70/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mState Transition Edge Cases[2m > [22mrapid pause/resume cycles emit all state changes
[31m[1mAssertionError[22m: expected 18 to be 6 // Object.is equality[39m

[32m- Expected[39m
[31m+ Received[39m

[32m- 6[39m
[31m+ 18[39m

[36m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m398:56[22m[39m
    [90m396| [39m
    [90m397| [39m      [90m// THEN: All transitions emit stateChange[39m
    [90m398| [39m      expect(eventSpies.stateChange.mock.calls.length).toBe(6); // 3 pâ€¦
    [90m   | [39m                                                       [31m^[39m
    [90m399| [39m    })[33m;[39m
    [90m400| [39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[71/79]âŽ¯[22m[39m

[41m[1m FAIL [22m[49m src/game/events/StateChangeActions.test.ts[2m > [22mState Change Actions: Events[2m > [22mSession vs Round State Correlation[2m > [22mround states only exist within playing session state
[31m[1mTypeError[22m: Cannot read properties of null (reading 'note')[39m
[36m [2mâ¯[22m GameOrchestrator.submitGuess src/game/GameOrchestrator.ts:[2m1185:67[22m[39m
    [90m1183| [39m   */[39m
    [90m1184| [39m  [34msubmitGuess[39m(guessedNote[33m:[39m [33mNoteWithOctave[39m)[33m:[39m [35mvoid[39m {
    [90m1185| [39m    console.log('[Orchestrator] submitGuess called:', guessedNote.noteâ€¦
    [90m   | [39m                                                                  [31m^[39m
    [90m1186| [39m    [35mif[39m ([33mLOGS_USER_ACTIONS_ENABLED[39m) {
    [90m1187| [39m      console.log('[Orchestrator] User submitted guess:', guessedNote.â€¦
[90m [2mâ¯[22m src/game/events/StateChangeActions.test.ts:[2m435:20[22m[39m

[31m[2mâŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[72/79]âŽ¯[22m[39m


[2m Test Files [22m [1m[31m8 failed[39m[22m[2m | [22m[1m[32m21 passed[39m[22m[90m (29)[39m
[2m      Tests [22m [1m[31m79 failed[39m[22m[2m | [22m[1m[32m563 passed[39m[22m[2m | [22m[33m3 skipped[39m[90m (645)[39m
[2m   Start at [22m 20:02:08
[2m   Duration [22m 6.22s[2m (transform 6.78s, setup 32.51s, collect 3.44s, tests 10.15s, environment 25.28s, prepare 799ms)[22m

